<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Secure PDF Viewer</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: #1a1a1a;
            color: white;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow text selection in text layers */
        .textLayer, .textLayer * {
            -webkit-user-select: text !important;
            user-select: text !important;
            -moz-user-select: text !important;
        }

        #viewerContainer {
            width: 100%;
            height: 100vh;
            overflow-y: auto; /* Allow vertical scroll */
            overflow-x: auto; /* Allow horizontal scroll when zoomed */
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 80px 20px 20px;
            position: relative;
        }

        /* Enable horizontal scroll when zoomed */
        #viewerContainer.zoomed {
            overflow-x: auto;
            overflow-y: auto; /* Keep vertical scroll enabled */
            align-items: flex-start; /* Align to left when zoomed for better scrolling */
            /* Ensure smooth scrolling in both directions */
            scroll-behavior: auto;
            /* Allow scrolling to negative values (left side) */
            padding-left: 0;
            padding-right: 0;
        }

        .page-wrapper {
            position: relative;
            margin: 10px 0; /* Small margin when not zoomed */
            display: block;
            width: 100%;
            max-width: 100%;
            background: #2a2a2a;
            border-radius: 8px;
            transform-origin: top left; /* Changed to top left for better scrolling */
            /* Allow horizontal scroll when zoomed */
            overflow: visible;
            min-width: fit-content;
            /* Ensure page stays visible */
            box-sizing: border-box;
            /* Prevent pages from overlapping when zoomed */
            isolation: isolate;
            /* Ensure minimum spacing between pages */
            min-height: fit-content;
            /* Center content when not zoomed */
            text-align: center;
        }
        
        .page-wrapper > * {
            margin: 0 auto; /* Center all children */
        }
        
        /* When zoomed, align to left for proper scrolling */
        .page-wrapper.zoomed {
            text-align: left;
        }
        
        .page-wrapper.zoomed > * {
            margin: 0; /* Remove auto margin when zoomed */
        }

        /* When zoomed, allow horizontal scrolling and increase spacing */
        .page-wrapper.zoomed {
            overflow-x: visible;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
            /* Ensure content is visible */
            display: block;
            /* Margin will be set dynamically via JavaScript */
        }

        /* Ensure text layer is selectable */
        .page-wrapper .textLayer {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
        }

        .pdf-canvas {
            margin: 0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 100%;
            display: block;
            background: white;
            image-rendering: -webkit-optimize-contrast;
        }

        /* Text Layer Container */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            text-align: initial;
            pointer-events: auto;
            transform-origin: 0% 0%;
            z-index: 2;
        }

        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
        }

        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgba(255, 235, 59, 0.3);
            border-radius: 2px;
        }

        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 255, 0.3);
        }

        .draw-canvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            border-radius: 8px;
            z-index: 3; /* Above text layer */
        }

        .draw-canvas.no-drawing {
            pointer-events: none;
        }

        .draw-canvas.pen-mode,
        .draw-canvas.eraser-mode {
            touch-action: none;
        }

        .draw-canvas.pen-mode {
            cursor: crosshair;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 9999;
            font-size: 22px;
            text-align: center;
            font-weight: 600;
            background: rgba(0,0,0,0.8);
            padding: 30px 50px;
            border-radius: 12px;
        }

        #loader #percent {
            display: block;
            margin-top: 10px;
            font-size: 16px;
            color: #aaa;
        }

        #controls {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(0,0,0,0.85);
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: opacity 0.3s ease, transform 0.3s ease;
            flex-wrap: wrap;
            max-width: 90vw;
        }

        #controls.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(-10px);
        }

        /* Auto-hide controls on mobile after inactivity */
        #controls.auto-hide {
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        #controls button {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 8px;
            border: none;
            background: #3d5a80;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
            -webkit-touch-callout: none;
        }

        #controls button:hover {
            background: #2c4458;
        }

        #controls button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #controls #pageInfo {
            padding: 0 12px;
            font-size: 14px;
            color: #ccc;
            white-space: nowrap;
        }

        #controls input {
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid #555;
            background: #2a2a2a;
            color: white;
            width: 70px;
        }

        #optionsMenu {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 10001;
        }

        #menuToggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3d5a80, #2c4458);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-touch-callout: none;
        }

        #menuToggle:active {
            transform: scale(0.95);
        }

        #menuToggle.active {
            transform: rotate(45deg);
        }

        #menuItems {
            position: absolute;
            bottom: 80px;
            right: 0;
            background: rgba(0,0,0,0.9);
            border-radius: 12px;
            padding: 10px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            opacity: 0;
            transform: translateY(20px) scale(0.9);
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #menuItems.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .menu-item {
            padding: 12px 16px;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            margin: 4px 0;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            -webkit-touch-callout: none;
        }

        .menu-item:active {
            background: rgba(61, 90, 128, 0.3);
        }

        .menu-item.active {
            background: rgba(61, 90, 128, 0.5);
        }

        .menu-item-icon {
            width: 20px;
            text-align: center;
        }

        /* Zoom Slider Styles */
        #zoomSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #2a2a2a;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3d5a80;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        #zoomSlider::-webkit-slider-thumb:hover {
            background: #5a7ba8;
        }

        #zoomSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3d5a80;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }

        #zoomSlider::-moz-range-thumb:hover {
            background: #5a7ba8;
        }

        /* Pan cursor when zoomed */
        body.pan-mode {
            cursor: grab;
        }

        body.pan-mode:active {
            cursor: grabbing;
        }

        /* ============================================
           ZOOM CONTROLS
        ============================================ */
        /* Zoom controls moved to menu - hide the separate zoom controls */
        #zoomControls {
            display: none;
        }

        /* ============================================
           THUMBNAIL SIDEBAR
        ============================================ */
        #thumbnailSidebar {
            position: fixed;
            left: -300px;
            top: 0;
            width: 280px;
            height: 100vh;
            background: rgba(26, 26, 26, 0.98);
            z-index: 10003;
            transition: left 0.3s ease;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0,0,0,0.5);
            padding: 80px 10px 20px;
        }

        #thumbnailSidebar.active {
            left: 0;
        }

        #thumbnailSidebar h3 {
            color: white;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid #444;
        }

        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
        }

        .thumbnail-item {
            background: #2a2a2a;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            border: 2px solid transparent;
        }

        .thumbnail-item:hover {
            transform: scale(1.05);
            background: #3a3a3a;
        }

        .thumbnail-item.active {
            border-color: #3d5a80;
            background: #3a3a3a;
        }

        .thumbnail-canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            background: white;
        }

        .thumbnail-page-num {
            text-align: center;
            color: #ccc;
            font-size: 11px;
            margin-top: 4px;
        }

        /* ============================================
           SEARCH PANEL
        ============================================ */
        #searchPanel {
            position: fixed;
            top: 70px;
            right: -400px;
            width: 350px;
            background: rgba(26, 26, 26, 0.98);
            z-index: 10004;
            transition: right 0.3s ease;
            box-shadow: -4px 0 20px rgba(0,0,0,0.5);
            border-radius: 12px 0 0 12px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #searchPanel.active {
            right: 0;
        }

        #searchInput {
            width: 100%;
            padding: 12px;
            border: 2px solid #3d5a80;
            border-radius: 8px;
            background: #2a2a2a;
            color: white;
            font-size: 14px;
            margin-bottom: 15px;
        }

        #searchInput:focus {
            outline: none;
            border-color: #5a7ba8;
        }

        .search-results {
            margin-top: 15px;
        }

        .search-result-item {
            padding: 10px;
            margin: 5px 0;
            background: #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: #3a3a3a;
        }

        .search-result-item .page-num {
            color: #3d5a80;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .search-result-item .context {
            color: #ccc;
            font-size: 12px;
        }

        .search-match {
            background: #ffeb3b;
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* ============================================
           FULLSCREEN MODE
        ============================================ */
        body.fullscreen {
            overflow: hidden;
        }

        body.fullscreen #viewerContainer {
            padding: 0;
            height: 100vh;
        }

        body.fullscreen #controls,
        body.fullscreen #optionsMenu {
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        body.fullscreen #controls:hover,
        body.fullscreen #optionsMenu:hover {
            opacity: 1;
        }

        /* ============================================
           NIGHT MODE
        ============================================ */
        body.night-mode {
            background: #0a0a0a;
        }

        body.night-mode .page-wrapper {
            background: #1a1a1a;
        }

        body.night-mode .pdf-canvas {
            filter: invert(1) hue-rotate(180deg);
        }

        /* ============================================
           TEXT SELECTION
        ============================================ */
        .text-selection-mode body {
            -webkit-user-select: text;
            user-select: text;
        }

        .text-selection-mode .pdf-canvas {
            cursor: text;
        }

        .highlight {
            position: absolute;
            background: rgba(255, 235, 59, 0.4);
            border-radius: 2px;
            pointer-events: none;
        }

        /* ============================================
           READING PROGRESS
        ============================================ */
        #readingProgress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #3d5a80, #5a7ba8);
            z-index: 10005;
            transition: width 0.3s ease;
        }

        /* ============================================
           STATISTICS PANEL
        ============================================ */
        #statsPanel {
            position: fixed;
            bottom: 100px;
            left: 30px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            z-index: 10006;
            font-size: 12px;
            color: #ccc;
            min-width: 200px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #statsPanel.active {
            opacity: 1;
            pointer-events: all;
        }

        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #3d5a80;
            font-weight: 600;
        }


        /* ============================================
           PAGE ROTATION
        ============================================ */
        .page-wrapper.rotated-90 {
            transform: rotate(90deg);
        }

        .page-wrapper.rotated-180 {
            transform: rotate(180deg);
        }

        .page-wrapper.rotated-270 {
            transform: rotate(-90deg);
        }

        @media (max-width: 768px) {
            #optionsMenu {
                bottom: 20px;
                right: 20px;
            }

            #menuToggle {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            #menuItems {
                min-width: 180px;
                bottom: 70px;
            }

            #controls {
                gap: 8px;
                padding: 10px 15px;
            }

            #controls button {
                padding: 6px 12px;
                font-size: 12px;
            }

            #controls input {
                width: 60px;
                padding: 6px 8px;
            }

            #viewerContainer {
                padding: 100px 10px 20px;
            }

            .page-wrapper {
                margin: 12px 0;
            }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body oncontextmenu="return false">

    <div id="controls" class="hidden">
        <button id="prevBtn">‚ü∏</button>
        <span id="pageInfo">Page 1 / ?</span>
        <button id="nextBtn">‚üπ</button>
        <input type="number" id="jumpPage" min="1" placeholder="Go to" />
        <button id="goBtn">Go</button>
    </div>

    <!-- Reading Progress Bar -->
    <div id="readingProgress"></div>

    <!-- Thumbnail Sidebar -->
    <div id="thumbnailSidebar">
        <h3>üìë ÿßŸÑÿµŸÅÿ≠ÿßÿ™</h3>
        <div class="thumbnail-grid" id="thumbnailGrid"></div>
    </div>

    <!-- Search Panel -->
    <div id="searchPanel">
        <h3 style="color: white; margin-bottom: 15px;">üîç ÿßŸÑÿ®ÿ≠ÿ´</h3>
        <input type="text" id="searchInput" placeholder="ÿßÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÜÿµ...">
        <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Statistics Panel -->
    <div id="statsPanel">
        <div class="stat-item">
            <span class="stat-label">ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©:</span>
            <span class="stat-value" id="pagesRead">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">ŸàŸÇÿ™ ÿßŸÑŸÇÿ±ÿßÿ°ÿ©:</span>
            <span class="stat-value" id="readingTime">0 ÿØŸÇŸäŸÇÿ©</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">ÿßŸÑÿ™ŸÇÿØŸÖ:</span>
            <span class="stat-value" id="readingProgressPercent">0%</span>
        </div>
    </div>

    <!-- Zoom Controls - Moved to menu -->
    <div id="zoomControls" style="display: none;">
        <div id="zoomLevel">100%</div>
    </div>


    <div id="optionsMenu">
        <button id="menuToggle">‚ò∞</button>
        <div id="menuItems">
            <div class="menu-item" id="toggleNav">
                <span class="menu-item-icon">üß≠</span>
                <span>Navigation</span>
            </div>
            <div class="menu-item" id="toggleThumbnails">
                <span class="menu-item-icon">üìë</span>
                <span>Thumbnails</span>
            </div>
            <div class="menu-item" id="toggleSearch">
                <span class="menu-item-icon">üîç</span>
                <span>Search</span>
            </div>
            <div class="menu-item" id="toggleFullscreen">
                <span class="menu-item-icon">‚õ∂</span>
                <span>Fullscreen</span>
            </div>
            <div class="menu-item" id="toggleNightMode">
                <span class="menu-item-icon">üåô</span>
                <span>Night Mode</span>
            </div>
            <div class="menu-item" id="toggleTextSelection">
                <span class="menu-item-icon">üìù</span>
                <span>Text Selection</span>
            </div>
            <div class="menu-item" id="penTool">
                <span class="menu-item-icon">‚úèÔ∏è</span>
                <span>Pen</span>
            </div>
            <div class="menu-item" id="eraserTool">
                <span class="menu-item-icon">üßπ</span>
                <span>Eraser</span>
            </div>
            <div class="menu-item" id="rotatePage">
                <span class="menu-item-icon">üîÑ</span>
                <span>Rotate</span>
            </div>
            <div class="menu-item" id="zoomControlItem" style="flex-direction: column; align-items: stretch; gap: 8px; padding: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 12px; color: #ccc;">Zoom Level</span>
                    <span id="zoomLevelDisplay" style="font-size: 14px; color: #3d5a80; font-weight: 600;">100%</span>
                </div>
                <input type="range" id="zoomSlider" min="50" max="200" value="100" step="5" 
                       style="width: 100%; height: 6px; background: #2a2a2a; border-radius: 3px; outline: none; cursor: pointer;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 4px;">
                    <span>50%</span>
                    <span>100%</span>
                    <span>200%</span>
                </div>
            </div>
            <div class="menu-item" id="zoomFit">
                <span class="menu-item-icon">‚õ∂</span>
                <span>Fit to Screen</span>
            </div>
            <div class="menu-item" id="zoomReset">
                <span class="menu-item-icon">‚Ü∫</span>
                <span>Reset Zoom</span>
            </div>
            <div class="menu-item" id="toggleStats">
                <span class="menu-item-icon">üìä</span>
                <span>Statistics</span>
            </div>
        </div>
    </div>

    <div id="loader">
        Loading PDF...
        <div id="percent">0%</div>
    </div>

    <div id="viewerContainer"></div>

    <script>
        // Device detection
        const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        const isLowEndDevice = window.deviceMemory <= 4 || navigator.hardwareConcurrency <= 2;
        
        document.onkeydown = function (e) {
            if (e.ctrlKey && ["s", "S", "p", "P", "u", "U"].includes(e.key)) {
                e.preventDefault();
            }
        };

        const params = new URLSearchParams(window.location.search);
        const id = params.get("id");

        if (!id) {
            document.getElementById("loader").innerText = "Invalid File ID";
            throw new Error("Missing id");
        }

        const BASE_URL = 'https://diaaapi.premiumasp.net/api';
        const url = `${BASE_URL}/Summary/${id}/file`;

        async function trackVisit(summaryId) {
            try {
                await fetch(`${BASE_URL}/Summary/${summaryId}/visit`, {
                    method: 'POST',
                    headers: {
                        'accept': '*/*',
                        'Content-Type': 'application/json'
                    }
                });
            } catch (err) {
                console.error('Error tracking visit:', err);
            }
        }

        trackVisit(id);
        
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

        function calculateScale() {
            const container = document.getElementById("viewerContainer");
            let containerWidth = window.innerWidth;
            
            if (container) {
                containerWidth = container.clientWidth;
            }
            
            const padding = window.innerWidth <= 768 ? 20 : 40;
            const availableWidth = containerWidth - padding;
            const standardPageWidth = 612;
            
            let scale = availableWidth / standardPageWidth;
            
            // Enhanced scale for high resolution rendering
            // iOS: More conservative to maintain performance
            if (isIOSSafari) {
                scale = Math.min(scale, 1.5); // Conservative: 1.5 for iOS (was 1.0, increased to 1.5)
            } else if (isAndroid) {
                scale = Math.min(scale, 2.2); // Increased from 1.1 to 2.2
            } else if (window.innerWidth > 1024) {
                scale = Math.min(scale, 3.0); // Increased from 1.8 to 3.0
            } else if (window.innerWidth > 768) {
                scale = Math.min(scale, 2.5); // Added for tablets
            }
            
            return Math.max(scale, 1.0); // Increased minimum from 0.6 to 1.0
        }

        let scale = calculateScale();
        let baseScale = scale;
        let pdfDoc = null;
        let currentPage = 1;
        let drawingMode = 'none';
        let drawCanvases = new Map();
        let pageWrappers = new Map();
        let renderedPages = new Set();
        let pagePromises = new Map();
        let activeRendering = 0;
        let renderAbortControllers = new Map(); // AbortController for each render
        let renderTimeouts = new Map(); // Timeout for each render
        let currentTargetPage = null; // Current page user wants to see
        let renderQueue = []; // Priority queue for page rendering
        let isProcessingQueue = false;
        let lastScrollTime = 0;
        let scrollVelocity = 0;
        let lastScrollPosition = 0;
        let visiblePages = new Set(); // Pages currently in viewport
        
        // Advanced features state
        let zoomLevel = 100;
        let isFullscreen = false;
        let isNightMode = false;
        let textSelectionMode = false;
        let pageRotations = new Map(); // Store rotation for each page
        let readingStartTime = Date.now();
        let pagesReadSet = new Set();
        let searchResults = [];
        let currentSearchIndex = -1;
        
        // Smart rendering based on device - Adaptive for maximum stability and quality
        let maxConcurrentRenders = 1;
        let pixelRatio = window.devicePixelRatio || 1;
        let maxImageSize = 512 * 512;
        let renderTimeout = 2000; // Adaptive timeout based on device
        
        // Adaptive pixelRatio: Balance quality vs performance based on device capabilities
        const deviceMemory = window.deviceMemory || 4; // Default to 4GB if unknown
        const hardwareConcurrency = navigator.hardwareConcurrency || 2;
        const screenWidth = window.screen.width || 1920;
        const screenHeight = window.screen.height || 1080;
        const screenPixels = screenWidth * screenHeight;
        const isHighDPI = window.devicePixelRatio >= 2;
        
        // Calculate optimal settings based on device capabilities
        if (isIOSSafari) {
            // iOS: Conservative for stability, but good quality
            maxConcurrentRenders = 1;
            // Adaptive pixelRatio: Higher for newer devices, lower for older
            if (deviceMemory >= 4 && hardwareConcurrency >= 4) {
                pixelRatio = Math.min(Math.max(pixelRatio, 2.0), 2.5); // 2.0-2.5 for newer iOS
            } else {
                pixelRatio = Math.min(Math.max(pixelRatio, 1.5), 2.0); // 1.5-2.0 for older iOS
            }
            maxImageSize = 1024 * 1024;
            renderTimeout = 2500; // Longer timeout for iOS
        } else if (isAndroid || isLowEndDevice) {
            // Android/Low-end: Safe defaults
            maxConcurrentRenders = deviceMemory >= 4 ? 2 : 1;
            if (deviceMemory >= 6 && hardwareConcurrency >= 4) {
                pixelRatio = Math.min(Math.max(pixelRatio, 2.0), 2.5); // Better devices
            } else {
                pixelRatio = Math.min(Math.max(pixelRatio, 1.5), 2.0); // Lower-end devices
            }
            maxImageSize = deviceMemory >= 4 ? 1536 * 1536 : 1024 * 1024;
            renderTimeout = 2000;
        } else if (isMobile) {
            // Other mobile devices
            maxConcurrentRenders = deviceMemory >= 4 ? 2 : 1;
            pixelRatio = Math.min(Math.max(pixelRatio, 2.0), 2.5);
            maxImageSize = 1536 * 1536;
            renderTimeout = 2000;
        } else {
            // Desktop: High quality, but adaptive based on hardware
            if (deviceMemory >= 8 && hardwareConcurrency >= 4) {
                // High-end desktop: Maximum quality
                maxConcurrentRenders = 3;
                pixelRatio = isHighDPI ? Math.min(Math.max(pixelRatio, 2.5), 3.0) : Math.min(Math.max(pixelRatio, 2.0), 2.5);
                maxImageSize = 4096 * 4096;
            } else if (deviceMemory >= 4) {
                // Mid-range desktop: Good quality
                maxConcurrentRenders = 2;
                pixelRatio = isHighDPI ? Math.min(Math.max(pixelRatio, 2.0), 2.5) : Math.min(Math.max(pixelRatio, 1.5), 2.0);
                maxImageSize = 2048 * 2048;
            } else {
                // Low-end desktop: Safe quality
                maxConcurrentRenders = 1;
                pixelRatio = Math.min(Math.max(pixelRatio, 1.5), 2.0);
                maxImageSize = 1536 * 1536;
            }
            renderTimeout = 1500; // Faster timeout for desktop
        }
        
        // Ensure pixelRatio is never too high to prevent memory issues
        const maxSafePixelRatio = Math.min(pixelRatio, 3.0);
        pixelRatio = maxSafePixelRatio;
        
        const loadingTask = pdfjsLib.getDocument({
            url: url,
            disableAutoFetch: false,
            disableStream: false,
            disableRange: false,
            maxImageSize: maxImageSize,
            isEvalSupported: false,
            useSystemFonts: isIOSSafari
        });

        loadingTask.onProgress = function (progress) {
            if (progress.total) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById("percent").innerText = percent + "%";
            }
        };

        loadingTask.promise.then(async (pdf) => {
            pdfDoc = pdf;
            await initializeLazyLoading();
            updateDrawingMode();
            setupNavigation();
            document.getElementById("loader").style.display = "none";
            updatePageInfo();
            updateReadingStats();
            
            // Initialize base scale
            baseScale = calculateScale();
            applyZoom(100);
        }).catch(err => {
            console.error("PDF.js Error:", err);
            document.getElementById("loader").innerHTML = "Failed to load PDF.<br>Please try again or use desktop.";
        });

        async function initializeLazyLoading() {
            const viewer = document.getElementById("viewerContainer");
            viewer.innerHTML = "";
            drawCanvases.clear();
            pageWrappers.clear();
            renderedPages.clear();
            pagePromises.clear();

            scale = calculateScale();

            // Create all page wrappers as placeholders
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.createElement("div");
                pageWrapper.className = "page-wrapper";
                pageWrapper.id = `page-${pageNum}`;
                pageWrapper.style.minHeight = "600px";
                viewer.appendChild(pageWrapper);
                pageWrappers.set(pageNum, pageWrapper);
            }

            // Render first page immediately
            await renderPage(1);
            if (pdfDoc.numPages > 1) await renderPage(2);

            // Setup intersection observer for lazy loading
            setupIntersectionObserver();
        }

        // Helper: Check if page should be rendered (priority check)
        function shouldRenderPage(pageNum) {
            // HARD RENDER LOCK: Always render if it's the target page - NEVER skip
            if (currentTargetPage === pageNum) return true;
            
            // Always render if it's visible
            if (visiblePages.has(pageNum)) return true;
            
            // Don't render if too far from target (but target page is already handled above)
            if (currentTargetPage && Math.abs(pageNum - currentTargetPage) > 3) return false;
            
            // Don't render if too far from current page during fast scroll
            if (scrollVelocity > 5 && Math.abs(pageNum - currentPage) > 2) return false;
            
            return true;
        }
        
        // Helper: Check if page has Hard Render Lock (target page protection)
        function hasHardRenderLock(pageNum) {
            return currentTargetPage === pageNum;
        }
        
        // Helper: Process render queue with priorities
        async function processRenderQueue() {
            if (isProcessingQueue || renderQueue.length === 0) return;
            if (activeRendering >= maxConcurrentRenders) return;
            
            isProcessingQueue = true;
            
            // Sort by priority (lower = higher priority)
            renderQueue.sort((a, b) => a.priority - b.priority);
            
            // Process highest priority items first
            while (renderQueue.length > 0 && activeRendering < maxConcurrentRenders) {
                const item = renderQueue.shift();
                if (!item || renderedPages.has(item.pageNum) || pagePromises.has(item.pageNum)) {
                    continue;
                }
                
                // HARD RENDER LOCK: Always process target page, skip others if needed
                if (!hasHardRenderLock(item.pageNum) && !shouldRenderPage(item.pageNum)) {
                    continue;
                }
                
                // Render with priority
                renderPage(item.pageNum, item.priority).catch(() => {
                    // Ignore errors
                });
                
                // Small delay between renders to prevent overload
                if (renderQueue.length > 0) {
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            
            isProcessingQueue = false;
        }
        
        // Helper: Queue page for rendering with priority
        function queuePageRender(pageNum, priority = 2) {
            if (renderedPages.has(pageNum) || pagePromises.has(pageNum)) return;
            
            // Remove if already in queue
            const existingIndex = renderQueue.findIndex(item => item.pageNum === pageNum);
            if (existingIndex >= 0) {
                // Update priority if new one is higher
                if (priority < renderQueue[existingIndex].priority) {
                    renderQueue[existingIndex].priority = priority;
                }
            } else {
                renderQueue.push({ pageNum, priority });
            }
            
            // Process queue
            processRenderQueue();
        }
        
        // Helper: Clean up memory for off-screen pages
        function cleanupOffScreenPages() {
            if (renderedPages.size <= 10) return; // Keep at least 10 pages
            
            const pagesToKeep = new Set();
            
            // Keep current page and nearby pages
            for (let i = Math.max(1, currentPage - 2); i <= Math.min(pdfDoc.numPages, currentPage + 2); i++) {
                pagesToKeep.add(i);
            }
            
            // Keep target page and nearby pages
            if (currentTargetPage) {
                for (let i = Math.max(1, currentTargetPage - 2); i <= Math.min(pdfDoc.numPages, currentTargetPage + 2); i++) {
                    pagesToKeep.add(i);
                }
            }
            
            // Keep visible pages
            visiblePages.forEach(p => pagesToKeep.add(p));
            
            // Clean up pages that are far away
            renderedPages.forEach(pageNum => {
                if (!pagesToKeep.has(pageNum) && Math.abs(pageNum - currentPage) > 5) {
                    const wrapper = pageWrappers.get(pageNum);
                    if (wrapper) {
                        // Clear canvas data to free memory
                        const canvas = wrapper.querySelector('.pdf-canvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        const drawCanvas = drawCanvases.get(pageNum);
                        if (drawCanvas) {
                            const drawCtx = drawCanvas.getContext('2d');
                            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                        }
                    }
                    renderedPages.delete(pageNum);
                    pagePromises.delete(pageNum);
                }
            });
        }
        
        async function renderPage(pageNum, priority = 0) {
            if (renderedPages.has(pageNum)) return;
            if (pagePromises.has(pageNum)) {
                // If already queued, update priority if this is higher
                const existing = renderQueue.find(item => item.pageNum === pageNum);
                if (existing && priority < existing.priority) {
                    existing.priority = priority;
                    renderQueue.sort((a, b) => a.priority - b.priority);
                }
                return pagePromises.get(pageNum);
            }

            // Check if page should be rendered
            if (!shouldRenderPage(pageNum)) {
                return;
            }

            const renderPromise = (async () => {
                // Create AbortController for this render
                const abortController = new AbortController();
                renderAbortControllers.set(pageNum, abortController);
                
                // HARD RENDER LOCK: Disable timeout cancellation for target page
                const isTargetPage = hasHardRenderLock(pageNum);
                const timeoutId = isTargetPage ? null : setTimeout(() => {
                    // Only cancel if not target page and not already rendered
                    if (!renderedPages.has(pageNum) && !hasHardRenderLock(pageNum)) {
                        abortController.abort();
                        renderAbortControllers.delete(pageNum);
                        pagePromises.delete(pageNum);
                        activeRendering = Math.max(0, activeRendering - 1);
                        
                        // Clean up partial render
                        const wrapper = pageWrappers.get(pageNum);
                        if (wrapper && !wrapper.querySelector('.pdf-canvas')) {
                            wrapper.innerHTML = '';
                        }
                    }
                }, renderTimeout);
                if (timeoutId) {
                    renderTimeouts.set(pageNum, timeoutId);
                }

                // Wait if too many renders happening (with cancellation check)
                let waitCount = 0;
                const maxWait = 40; // Max 2 seconds wait (40 * 50ms)
                while (activeRendering >= maxConcurrentRenders && waitCount < maxWait) {
                    // HARD RENDER LOCK: Never cancel target page, ignore abort for target
                    if (!isTargetPage && (abortController.signal.aborted || !shouldRenderPage(pageNum))) {
                        if (timeoutId) clearTimeout(timeoutId);
                        renderTimeouts.delete(pageNum);
                        renderAbortControllers.delete(pageNum);
                        return;
                    }
                    await new Promise(r => setTimeout(r, 50));
                    waitCount++;
                }
                
                // HARD RENDER LOCK: Target page always gets priority, never skip
                if (!isTargetPage && activeRendering >= maxConcurrentRenders * 2) {
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pageNum);
                    renderAbortControllers.delete(pageNum);
                    return;
                }

                // HARD RENDER LOCK: Final cancellation check - ignore for target page
                if (!isTargetPage && (abortController.signal.aborted || !shouldRenderPage(pageNum))) {
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pageNum);
                    renderAbortControllers.delete(pageNum);
                    return;
                }

                activeRendering++;
                
                try {
                    if (renderedPages.has(pageNum)) {
                        if (timeoutId) clearTimeout(timeoutId);
                        renderTimeouts.delete(pageNum);
                        renderAbortControllers.delete(pageNum);
                        return;
                    }

                    // HARD RENDER LOCK: Ignore abort for target page
                    if (!isTargetPage && abortController.signal.aborted) return;

                    const page = await pdfDoc.getPage(pageNum);
                    
                    // HARD RENDER LOCK: Ignore cancellation checks for target page
                    if (!isTargetPage && (abortController.signal.aborted || !shouldRenderPage(pageNum))) {
                        return;
                    }
                    // Always use baseScale for viewport - zoom is handled by CSS transform
                    const viewport = page.getViewport({ scale: baseScale });

                    const pageWrapper = pageWrappers.get(pageNum);
                    if (!pageWrapper) return;

                    pageWrapper.innerHTML = "";
                    pageWrapper.style.minHeight = "";
                
                const pdfCanvas = document.createElement("canvas");
                pdfCanvas.className = "pdf-canvas";
                
                    // High resolution canvas rendering
                    pdfCanvas.width = Math.floor(viewport.width * pixelRatio);
                    pdfCanvas.height = Math.floor(viewport.height * pixelRatio);
                pdfCanvas.style.width = viewport.width + "px";
                pdfCanvas.style.height = viewport.height + "px";

                    const ctx = pdfCanvas.getContext("2d", { alpha: false });
                    ctx.scale(pixelRatio, pixelRatio);
                
                    // HARD RENDER LOCK: Ignore abort for target page
                    if (!isTargetPage && abortController.signal.aborted) return;
                    
                    await page.render({
                        canvasContext: ctx,
                        viewport: viewport
                    }).promise;
                    
                    // HARD RENDER LOCK: Ignore abort for target page
                    if (!isTargetPage && abortController.signal.aborted) return;

                // Create text layer container
                const textLayerDiv = document.createElement("div");
                textLayerDiv.className = "textLayer";
                textLayerDiv.style.width = viewport.width + "px";
                textLayerDiv.style.height = viewport.height + "px";
                textLayerDiv.style.left = "50%";
                textLayerDiv.style.transform = "translateX(-50%)";
                textLayerDiv.style.position = "absolute";
                textLayerDiv.style.top = "0";

                    // HARD RENDER LOCK: Ignore abort for target page
                    if (!isTargetPage && abortController.signal.aborted) return;
                    
                    // Render text layer for selectable text
                    const textContent = await page.getTextContent();
                    
                    // HARD RENDER LOCK: Ignore abort for target page
                    if (!isTargetPage && abortController.signal.aborted) return;
                const textItems = textContent.items;
                
                // On iOS, limit text items to prevent performance issues
                const maxTextItems = isIOSSafari ? 500 : textItems.length;
                const itemsToRender = textItems.slice(0, maxTextItems);
                
                // Create text layer using PDF.js text layer rendering
                // This creates selectable, searchable text overlays
                for (let i = 0; i < itemsToRender.length; i++) {
                    const textItem = itemsToRender[i];
                    
                    // Transform coordinates from PDF space to viewport space
                    // textItem.transform is [a, b, c, d, e, f] where:
                    // - [a, b, c, d] is the transformation matrix
                    // - [e, f] is the translation
                    const transform = textItem.transform;
                    const scaleX = Math.hypot(transform[0], transform[1]);
                    const scaleY = Math.hypot(transform[2], transform[3]);
                    const angle = Math.atan2(transform[1], transform[0]);
                    
                    // Calculate position in viewport coordinates
                    const tx = transform[4];
                    const ty = transform[5];
                    
                    // Create text span element
                    const textDiv = document.createElement("span");
                    textDiv.textContent = textItem.str;
                    
                    // Position the text span (PDF coordinates are bottom-up, CSS is top-down)
                    textDiv.style.left = tx + "px";
                    textDiv.style.top = (viewport.height - ty) + "px";
                    textDiv.style.fontSize = scaleY + "px";
                    textDiv.style.fontFamily = textItem.fontName || "sans-serif";
                    textDiv.style.width = (textItem.width || scaleX * textItem.str.length) + "px";
                    textDiv.style.height = scaleY + "px";
                    
                    // Apply rotation if needed
                    if (Math.abs(angle) > 0.001) {
                        textDiv.style.transform = `rotate(${angle}rad)`;
                        textDiv.style.transformOrigin = "0% 0%";
                    }
                    
                    // Style for text selection
                    textDiv.style.position = "absolute";
                    textDiv.style.whiteSpace = "pre";
                    textDiv.style.cursor = "text";
                    textDiv.style.color = "transparent";
                    textDiv.style.userSelect = "text";
                    textDiv.style.webkitUserSelect = "text";
                    textDiv.style.mozUserSelect = "text";
                    textDiv.style.msUserSelect = "text";
                    textDiv.style.lineHeight = "1.0";
                    textDiv.style.overflow = "hidden";
                    
                    // Add to text layer
                    textLayerDiv.appendChild(textDiv);
                }

                const drawCanvas = document.createElement("canvas");
                drawCanvas.className = "draw-canvas";
                
                    drawCanvas.width = Math.floor(viewport.width * pixelRatio);
                    drawCanvas.height = Math.floor(viewport.height * pixelRatio);
                drawCanvas.style.width = viewport.width + "px";
                drawCanvas.style.height = viewport.height + "px";
                
                const drawCtx = drawCanvas.getContext("2d");
                    drawCtx.scale(pixelRatio, pixelRatio);

                // Append elements in correct z-order: canvas (bottom), text layer (middle), draw canvas (top)
                pageWrapper.appendChild(pdfCanvas);
                pageWrapper.appendChild(textLayerDiv);
                pageWrapper.appendChild(drawCanvas);

                // Store base dimensions for zoom (actual viewport dimensions)
                pageWrapper.dataset.baseWidth = viewport.width + "";
                pageWrapper.dataset.baseHeight = viewport.height + "";

                // Apply current zoom level using CSS transform
                const currentZoomFactor = zoomLevel / 100;
                pageWrapper.style.transform = `scale(${currentZoomFactor})`;
                pageWrapper.style.transformOrigin = "top left"; // Changed to top left for better scrolling
                
                // Enable horizontal scroll when zoomed
                if (zoomLevel > 100) {
                    pageWrapper.classList.add("zoomed");
                    // Set actual width to allow horizontal scrolling
                    pageWrapper.style.width = (viewport.width * currentZoomFactor) + "px";
                    pageWrapper.style.minWidth = (viewport.width * currentZoomFactor) + "px";
                    pageWrapper.style.maxWidth = "none";
                    // Calculate proper margin to prevent overlap
                    // Use minimum margin that scales with zoom to ensure separation
                    // Calculate margin: small and relative to zoom level
                    // Keep margins small at all zoom levels (including when zoomed out)
                    const baseMargin = 10; // Small base margin
                    const scaledHeight = viewport.height * currentZoomFactor;
                    // Very small percentage of height - just enough to prevent overlap
                    const heightBasedMargin = scaledHeight * 0.008; // Only 0.8% of scaled height
                    // Use the smaller value to keep margins minimal at all zoom levels
                    const totalMargin = Math.max(baseMargin, heightBasedMargin + 3); // Small buffer
                    
                    // Apply margin to ensure pages never overlap (but keep it small)
                    pageWrapper.style.marginTop = totalMargin + "px";
                    pageWrapper.style.marginBottom = totalMargin + "px";
                    pageWrapper.style.minHeight = scaledHeight + "px";
                } else {
                    pageWrapper.style.width = "";
                    pageWrapper.style.minWidth = "";
                    pageWrapper.style.maxWidth = "100%";
                    pageWrapper.style.marginTop = "";
                    pageWrapper.style.marginBottom = "";
                }

                    drawCanvases.set(pageNum, drawCanvas);
                    enableDrawing(drawCanvas);
                    renderedPages.add(pageNum);

                    // Clean up cancellation resources
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pageNum);
                    renderAbortControllers.delete(pageNum);
                    
                    // HARD RENDER LOCK: Clear target page flag after successful render
                    if (isTargetPage && currentTargetPage === pageNum) {
                        // Keep target page flag until scroll completes, but mark as rendered
                    }
                    
                    // Periodic memory cleanup
                    if (pageNum % 5 === 0) {
                        cleanupOffScreenPages();
                        // Small delay to prevent blocking
                        if (isIOSSafari || isLowEndDevice) {
                            await new Promise(r => setTimeout(r, 100));
                        }
                    }
                } catch (err) {
                    // HARD RENDER LOCK: Always log errors for target page, ignore abort for target
                    if (isTargetPage || !abortController.signal.aborted) {
                        console.error(`Error rendering page ${pageNum}:`, err);
                        const pageWrapper = pageWrappers.get(pageNum);
                        if (pageWrapper) {
                            pageWrapper.innerHTML = '<div style="text-align:center;padding:20px;color:#f00;">Error</div>';
                        }
                    }
                } finally {
                    activeRendering--;
                    pagePromises.delete(pageNum);
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pageNum);
                    renderAbortControllers.delete(pageNum);
                }
            })();

            pagePromises.set(pageNum, renderPromise);
            return renderPromise;
        }

        function setupIntersectionObserver() {
            if (!('IntersectionObserver' in window)) return;

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.id.replace('page-', ''));
                        
                        // Mark as visible
                        visiblePages.add(pageNum);
                        
                        // Only render if close to current target or current page
                        const target = currentTargetPage || currentPage || 1;
                        const distance = Math.abs(pageNum - target);
                        
                        // Limit rendering to nearby pages only, and respect scroll velocity
                        if (distance <= 3 && (scrollVelocity < 10 || distance <= 1)) {
                            // Priority: 0 = target page, 1 = visible, 2 = nearby
                            const priority = pageNum === target ? 0 : (visiblePages.has(pageNum) ? 1 : 2);
                            queuePageRender(pageNum, priority);
                            
                            // Pre-render next page only if very close and not scrolling fast
                            if (pageNum < pdfDoc.numPages && distance <= 2 && scrollVelocity < 5) {
                                queuePageRender(pageNum + 1, 2);
                            }
                        }
                    } else {
                        // Remove from visible set when out of view
                        const pageNum = parseInt(entry.target.id.replace('page-', ''));
                        visiblePages.delete(pageNum);
                    }
                });
            }, {
                rootMargin: isMobile ? '150px' : '200px' // Adaptive based on device
            });

            pageWrappers.forEach(wrapper => observer.observe(wrapper));
        }

        function enableDrawing(canvas) {
            const ctx = canvas.getContext("2d");
            let drawing = false;

            function getCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function startDrawing(e) {
                if (drawingMode === 'none') return;
                e.preventDefault();
                drawing = true;
                const coords = getCoordinates(e);
                ctx.beginPath();
                ctx.moveTo(coords.x, coords.y);
            }

            function draw(e) {
                if (!drawing || drawingMode === 'none') return;
                e.preventDefault();
                const coords = getCoordinates(e);

                if (drawingMode === 'pen') {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = '#ffeb3b';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                } else if (drawingMode === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = 20;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                }

                    ctx.lineTo(coords.x, coords.y);
                    ctx.stroke();
            }

            function stopDrawing(e) {
                drawing = false;
                ctx.beginPath();
            }

            canvas.addEventListener("mousedown", startDrawing, false);
            canvas.addEventListener("mousemove", draw, false);
            canvas.addEventListener("mouseup", stopDrawing, false);
            canvas.addEventListener("mouseleave", stopDrawing, false);

            canvas.addEventListener("touchstart", startDrawing, { passive: false });
            canvas.addEventListener("touchmove", draw, { passive: false });
            canvas.addEventListener("touchend", stopDrawing, { passive: false });
            canvas.addEventListener("touchcancel", stopDrawing, { passive: false });
        }

        function updateDrawingMode() {
            drawCanvases.forEach(canvas => {
                canvas.className = "draw-canvas";
                if (drawingMode === 'pen') {
                    canvas.classList.add('pen-mode');
                } else if (drawingMode === 'eraser') {
                    canvas.classList.add('eraser-mode');
                } else {
                    canvas.classList.add('no-drawing');
                }
            });
        }

        // Helper: Cancel renders far from target
        function cancelDistantRenders(targetPage) {
            renderAbortControllers.forEach((controller, pNum) => {
                // HARD RENDER LOCK: NEVER cancel the target page
                if (pNum === targetPage) return;
                
                const distance = Math.abs(pNum - targetPage);
                if (distance > 3 || (distance > 1 && !visiblePages.has(pNum))) {
                    controller.abort();
                    const timeoutId = renderTimeouts.get(pNum);
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pNum);
                    renderAbortControllers.delete(pNum);
                    if (pagePromises.has(pNum)) {
                        pagePromises.delete(pNum);
                    }
                    activeRendering = Math.max(0, activeRendering - 1);
                }
            });
        }
        
        async function scrollToPage(pageNum) {
            if (!pdfDoc || pageNum < 1 || pageNum > pdfDoc.numPages) return;
            
            // Set current target page for prioritization
            currentTargetPage = pageNum;
            
            // Cancel renders that are far from target
            cancelDistantRenders(pageNum);
            
            // Clean up memory before rendering new page
            cleanupOffScreenPages();
            
            // Prioritize target page render (highest priority = 0)
            if (!renderedPages.has(pageNum)) {
                // HARD RENDER LOCK: Only cancel existing promise if it's NOT already the target page
                // If it's already the target, let it continue rendering
                if (pagePromises.has(pageNum) && currentTargetPage !== pageNum) {
                    const controller = renderAbortControllers.get(pageNum);
                    if (controller) {
                        controller.abort();
                        renderAbortControllers.delete(pageNum);
                    }
                    const timeoutId = renderTimeouts.get(pageNum);
                    if (timeoutId) clearTimeout(timeoutId);
                    renderTimeouts.delete(pageNum);
                    pagePromises.delete(pageNum);
                }
                
                // Render with highest priority (or wait for existing render if already target)
                if (!pagePromises.has(pageNum)) {
                    await renderPage(pageNum, 0);
                } else {
                    // Wait for existing render to complete (it's already the target)
                    await pagePromises.get(pageNum);
                }
            }
            
            const pageElement = pageWrappers.get(pageNum);
            if (pageElement) {
                const container = document.getElementById("viewerContainer");
                
                // Smooth scroll to page center - improved navigation
                const containerRect = container.getBoundingClientRect();
                const pageRect = pageElement.getBoundingClientRect();
                const scrollTop = container.scrollTop + pageRect.top - containerRect.top - (containerRect.height / 2) + (pageRect.height / 2);
                
                container.scrollTo({
                    top: Math.max(0, scrollTop),
                    behavior: 'smooth'
                });
                
                currentPage = pageNum;
                updatePageInfo();
            }
        }

        function updatePageInfo() {
            const pageInfo = document.getElementById("pageInfo");
            if (pageInfo && pdfDoc) {
                pageInfo.textContent = `Page ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        let scrollTimeout;
        let scrollThrottleTimeout;
        document.getElementById("viewerContainer").addEventListener("scroll", () => {
            const now = Date.now();
            const container = document.getElementById("viewerContainer");
            const currentScroll = container.scrollTop;
            
            // Calculate scroll velocity
            if (lastScrollTime > 0) {
                const timeDelta = now - lastScrollTime;
                const scrollDelta = Math.abs(currentScroll - lastScrollPosition);
                scrollVelocity = timeDelta > 0 ? scrollDelta / timeDelta * 1000 : 0; // pixels per second
            }
            lastScrollTime = now;
            lastScrollPosition = currentScroll;
            
            // Update visible pages immediately (throttled)
            clearTimeout(scrollThrottleTimeout);
            scrollThrottleTimeout = setTimeout(() => {
                visiblePages.clear();
                const viewportTop = container.scrollTop;
                const viewportBottom = viewportTop + container.clientHeight;
                
                pageWrappers.forEach((wrapper, pageNum) => {
                    const rect = wrapper.getBoundingClientRect();
                    const wrapperTop = rect.top + container.scrollTop;
                    const wrapperBottom = wrapperTop + rect.height;
                    
                    // Page is visible if it overlaps with viewport
                    if (wrapperBottom >= viewportTop && wrapperTop <= viewportBottom) {
                        visiblePages.add(pageNum);
                    }
                });
                
                // Queue visible pages for rendering with priority
                visiblePages.forEach(pageNum => {
                    if (!renderedPages.has(pageNum) && !pagePromises.has(pageNum)) {
                        queuePageRender(pageNum, 1); // Priority 1 for visible pages
                    }
                });
            }, 100);
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const centerY = container.clientHeight / 2;

                pageWrappers.forEach((wrapper, pageNum) => {
                    const rect = wrapper.getBoundingClientRect();
                    const wrapperCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(wrapperCenter - centerY);

                    if (distance < container.clientHeight / 2) {
                        currentPage = pageNum;
                    }
                });

                updatePageInfo();
                updateActiveThumbnail();
                updateReadingStats();
                
                // Clean up memory after scroll settles
                cleanupOffScreenPages();
                
                // Reset scroll velocity
                scrollVelocity = 0;
            }, 150);
        });

        function setupNavigation() {
            document.getElementById("nextBtn").onclick = () => {
                    if (pdfDoc && currentPage < pdfDoc.numPages) {
                        scrollToPage(currentPage + 1);
                    }
                };

            document.getElementById("prevBtn").onclick = () => {
                    if (pdfDoc && currentPage > 1) {
                        scrollToPage(currentPage - 1);
                    }
                };

            document.getElementById("goBtn").onclick = () => {
                const p = parseInt(document.getElementById("jumpPage").value);
                if (pdfDoc && p >= 1 && p <= pdfDoc.numPages) {
                        scrollToPage(p);
                    document.getElementById("jumpPage").value = "";
                    }
                };

            document.getElementById("jumpPage").addEventListener("keypress", (e) => {
                    if (e.key === "Enter") {
                    document.getElementById("goBtn").click();
                }
            });
        }

        const menuToggle = document.getElementById("menuToggle");
        const menuItems = document.getElementById("menuItems");
        let menuOpen = false;

        menuToggle.addEventListener("click", () => {
            menuOpen = !menuOpen;
            menuItems.classList.toggle("active", menuOpen);
            menuToggle.classList.toggle("active", menuOpen);
            menuToggle.textContent = menuOpen ? "‚úï" : "‚ò∞";
        });

        document.getElementById("toggleNav").addEventListener("click", () => {
            const controls = document.getElementById("controls");
            controls.classList.toggle("hidden");
            document.getElementById("toggleNav").classList.toggle("active");
        });

        // ============================================
        // TOUCH TO TOGGLE CONTROLS (Mobile)
        // ============================================
        let controlsAutoHideTimeout = null;
        let lastTouchTime = 0;
        let touchStartY = 0;
        let touchStartX = 0;
        const TOUCH_DELAY = 300; // Delay to distinguish tap from scroll/draw
        const SWIPE_THRESHOLD = 30; // Minimum distance for swipe

        function showControls() {
            const controls = document.getElementById("controls");
            controls.classList.remove("hidden");
            controls.classList.add("auto-hide");
            
            // Clear existing timeout
            if (controlsAutoHideTimeout) {
                clearTimeout(controlsAutoHideTimeout);
            }
            
            // Auto-hide after 3 seconds on mobile
            if (isMobile) {
                controlsAutoHideTimeout = setTimeout(() => {
                    if (!controls.classList.contains("hidden")) {
                        controls.classList.add("hidden");
                    }
                }, 3000);
            }
        }

        function hideControls() {
            const controls = document.getElementById("controls");
            controls.classList.add("hidden");
            if (controlsAutoHideTimeout) {
                clearTimeout(controlsAutoHideTimeout);
            }
        }

        function toggleControls() {
            const controls = document.getElementById("controls");
            if (controls.classList.contains("hidden")) {
                showControls();
            } else {
                hideControls();
            }
        }

        // Touch event handlers for mobile - Toggle controls with tap
        if (isMobile) {
            const viewerContainer = document.getElementById("viewerContainer");
            let touchStartTime = 0;
            let touchMoved = false;
            let touchStartX = 0;
            let touchStartY = 0;

            // Separate touch handler for controls toggle (single finger only)
            viewerContainer.addEventListener("touchstart", (e) => {
                // Only handle single touch (not pinch zoom)
                // Skip if already handling pinch zoom or multiple touches
                if (e.touches.length !== 1 || isPinching || e.touches.length === 2) {
                    return;
                }

                // Don't interfere with drawing or other interactions
                if (drawingMode !== 'none' || e.target.closest('.draw-canvas') || 
                    e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                    e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                    e.target.closest('#searchPanel') || e.target.closest('.textLayer')) {
                    return;
                }

                touchStartTime = Date.now();
                touchMoved = false;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });

            viewerContainer.addEventListener("touchmove", (e) => {
                // Only handle single touch
                // Skip if already handling pinch zoom or multiple touches
                if (e.touches.length !== 1 || isPinching || e.touches.length === 2) {
                    touchMoved = true;
                    return;
                }

                if (drawingMode !== 'none' || e.target.closest('.draw-canvas')) {
                    return;
                }

                // Check if user is scrolling (moved more than threshold)
                if (e.touches.length > 0) {
                    const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
                    const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
                    if (deltaX > SWIPE_THRESHOLD || deltaY > SWIPE_THRESHOLD) {
                        touchMoved = true;
                    }
                }
            }, { passive: true });

            viewerContainer.addEventListener("touchend", (e) => {
                // Only handle single touch
                // Skip if was pinching or multiple touches
                if (e.changedTouches.length !== 1 || isPinching || e.touches.length === 2) {
                    touchMoved = false;
                    return;
                }

                // Don't interfere with drawing or other interactions
                if (drawingMode !== 'none' || e.target.closest('.draw-canvas') || 
                    e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                    e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                    e.target.closest('#searchPanel') || e.target.closest('.textLayer')) {
                    touchMoved = false;
                    return;
                }

                const touchDuration = Date.now() - touchStartTime;
                
                // Single tap (not a scroll or draw) - toggle controls
                if (!touchMoved && touchDuration < TOUCH_DELAY && touchDuration > 50) {
                    // Check if it's a single tap (not double tap)
                    const timeSinceLastTouch = Date.now() - lastTouchTime;
                    if (timeSinceLastTouch < 400) {
                        // Double tap detected - don't toggle, let zoom handle it
                        lastTouchTime = 0;
                    } else {
                        // Single tap - toggle controls
                        lastTouchTime = Date.now();
                        setTimeout(() => {
                            if (Date.now() - lastTouchTime >= 400) {
                                toggleControls();
                            }
                        }, 400);
                    }
                }
                
                touchMoved = false;
            }, { passive: true });

            // Don't show controls automatically on scroll - only on tap

            // Show controls initially on mobile
            setTimeout(() => {
                showControls();
            }, 1000);
        }

        document.getElementById("penTool").addEventListener("click", () => {
            drawingMode = drawingMode === 'pen' ? 'none' : 'pen';
            updateDrawingMode();
            document.getElementById("penTool").classList.toggle("active", drawingMode === 'pen');
        });

        document.getElementById("eraserTool").addEventListener("click", () => {
            drawingMode = drawingMode === 'eraser' ? 'none' : 'eraser';
            updateDrawingMode();
            document.getElementById("eraserTool").classList.toggle("active", drawingMode === 'eraser');
        });

        // ============================================
        // ZOOM CONTROLS
        // ============================================
        // Smooth zoom animation
        let zoomAnimationFrame = null;
        let targetZoomLevel = 100;
        
        function applyZoom(newZoom, animate = true, centerX = null, centerY = null) {
            // Zoom limits: 50% minimum, 200% maximum for all devices
            const maxZoom = 200;
            const minZoom = 50;
            
            targetZoomLevel = Math.max(minZoom, Math.min(maxZoom, newZoom));
            
            // Cancel any ongoing animation
            if (zoomAnimationFrame) {
                cancelAnimationFrame(zoomAnimationFrame);
            }
            
            // Keep scale constant - only change CSS transform for zoom
            scale = baseScale; // Always use baseScale for rendering
            
            const container = document.getElementById("viewerContainer");
            const startZoom = zoomLevel;
            const zoomDiff = targetZoomLevel - startZoom;
            const startTime = performance.now();
            const duration = animate ? 200 : 0; // 200ms smooth animation
            
            function animateZoom(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth zoom (ease-out)
                const easeOut = 1 - Math.pow(1 - progress, 3);
                
                zoomLevel = startZoom + (zoomDiff * easeOut);
                
                // Update zoom level display
                const zoomLevelEl = document.getElementById("zoomLevel");
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = Math.round(zoomLevel) + "%";
                }
                
                // Update slider
                updateZoomSlider();
                
                // Check if zoomed (more than 100%)
                const isZoomed = zoomLevel > 100;
                
                // Enable/disable horizontal scroll based on zoom level
                if (isZoomed) {
                    container.classList.add("zoomed");
                } else {
                    container.classList.remove("zoomed");
                }
                
                // Apply CSS transform to all page wrappers
                const zoomFactor = zoomLevel / 100;
                pageWrappers.forEach((wrapper, pageNum) => {
                    if (wrapper) {
                        // Get base dimensions
                        let baseWidth = parseFloat(wrapper.dataset.baseWidth || "0");
                        let baseHeight = parseFloat(wrapper.dataset.baseHeight || "0");
                        
                        // Store base dimensions if not already stored
                        if (baseWidth === 0 || baseHeight === 0) {
                            // Get actual dimensions from first child (canvas)
                            const canvas = wrapper.querySelector('.pdf-canvas');
                            if (canvas) {
                                baseWidth = parseFloat(canvas.style.width) || canvas.offsetWidth;
                                baseHeight = parseFloat(canvas.style.height) || canvas.offsetHeight;
                            } else {
                                // Fallback: calculate from current size
                                const currentWidth = wrapper.offsetWidth;
                                const currentHeight = wrapper.offsetHeight;
                                const currentScale = wrapper.style.transform ? parseFloat(wrapper.style.transform.match(/scale\(([^)]+)\)/)?.[1] || 1) : 1;
                                baseWidth = currentWidth / currentScale;
                                baseHeight = currentHeight / currentScale;
                            }
                            wrapper.dataset.baseWidth = baseWidth + "";
                            wrapper.dataset.baseHeight = baseHeight + "";
                        }
                        
                        // Apply transform to zoom the entire page
                        // Always use top left origin to allow proper scrolling in all directions
                        wrapper.style.transform = `scale(${zoomFactor})`;
                        wrapper.style.transformOrigin = "top left";
                        
                        // Enable horizontal scroll on page wrapper when zoomed
                        if (isZoomed) {
                            wrapper.classList.add("zoomed");
                            // Set actual width to allow scrolling
                            if (baseWidth > 0) {
                                const scaledWidth = baseWidth * zoomFactor;
                                wrapper.style.width = scaledWidth + "px";
                                wrapper.style.minWidth = scaledWidth + "px";
                                wrapper.style.maxWidth = "none";
                                // Ensure wrapper can scroll horizontally
                                wrapper.style.overflowX = "visible";
                            }
                            
                            // Center the scaled page within container when zoomed
                            // This allows scrolling in all directions
                            const container = document.getElementById("viewerContainer");
                            const containerWidth = container.clientWidth;
                            const scaledPageWidth = baseWidth * zoomFactor;
                            
                            // If page is wider than container, allow left scrolling
                            if (scaledPageWidth > containerWidth) {
                                wrapper.style.marginLeft = "0";
                                wrapper.style.marginRight = "auto";
                            }
                            
                            // Calculate margin: small at all zoom levels (including when zoomed out)
                            // Keep margins small and proportional to prevent overlap without being too large
                            const baseMargin = 10; // Small base margin
                            const scaledHeight = baseHeight * zoomFactor;
                            // Very small percentage of height - just enough to prevent overlap
                            const heightBasedMargin = scaledHeight * 0.008; // Only 0.8% of scaled height
                            // Use the smaller value to keep margins minimal at all zoom levels
                            const totalMargin = Math.max(baseMargin, heightBasedMargin + 3); // Small buffer
                            
                            // Apply margin to ensure pages never overlap (but keep it small)
                            wrapper.style.marginTop = totalMargin + "px";
                            wrapper.style.marginBottom = totalMargin + "px";
                            
                            // Ensure wrapper has proper spacing and doesn't collapse
                            wrapper.style.display = "block";
                            wrapper.style.minHeight = scaledHeight + "px";
                        } else {
                            wrapper.classList.remove("zoomed");
                            wrapper.style.width = "";
                            wrapper.style.minWidth = "";
                            wrapper.style.maxWidth = "100%";
                            wrapper.style.marginTop = "";
                            wrapper.style.marginBottom = "";
                            wrapper.style.paddingTop = "";
                            wrapper.style.paddingBottom = "";
                        }
                    }
                });
                
                // Adjust scroll position if center point is provided
                if (centerX !== null && centerY !== null && progress > 0) {
                    const zoomFactorChange = zoomLevel / startZoom;
                    const containerRect = container.getBoundingClientRect();
                    // Calculate relative position from viewport (not including scroll)
                    const relativeX = centerX - containerRect.left;
                    const relativeY = centerY - containerRect.top;
                    
                    // Adjust scroll to keep the point in view
                    // For top-left origin, we need to adjust differently
                    const newScrollLeft = container.scrollLeft + (relativeX * (zoomFactorChange - 1));
                    const newScrollTop = container.scrollTop + (relativeY * (zoomFactorChange - 1));
                    
                    container.scrollLeft = Math.max(0, newScrollLeft);
                    container.scrollTop = Math.max(0, newScrollTop);
                }
                
                if (progress < 1) {
                    zoomAnimationFrame = requestAnimationFrame(animateZoom);
                } else {
                    zoomLevel = targetZoomLevel; // Ensure final value
                    zoomAnimationFrame = null;
                }
            }
            
            if (animate && duration > 0) {
                zoomAnimationFrame = requestAnimationFrame(animateZoom);
            } else {
                zoomLevel = targetZoomLevel;
                animateZoom(performance.now());
            }
        }

        // Zoom slider control - now in menu
        let zoomSlider = null;
        let zoomLevelDisplay = null;
        
        // Initialize zoom slider after DOM is ready
        function initZoomSlider() {
            zoomSlider = document.getElementById("zoomSlider");
            zoomLevelDisplay = document.getElementById("zoomLevelDisplay");
            
            if (zoomSlider) {
                // Set initial value
                zoomSlider.value = zoomLevel;
                
                // Zoom slider input with smooth updates
                let sliderTimeout = null;
                zoomSlider.addEventListener("input", (e) => {
                    const newZoom = parseInt(e.target.value);
                    
                    // Update display immediately for responsive feedback
                    if (zoomLevelDisplay) {
                        zoomLevelDisplay.textContent = newZoom + "%";
                    }
                    
                    // Throttle zoom application for smooth slider experience
                    clearTimeout(sliderTimeout);
                    sliderTimeout = setTimeout(() => {
                        applyZoom(newZoom, true);
                    }, 50); // Small delay for smooth slider feel
                });
                
                // Apply zoom on slider release for final value
                zoomSlider.addEventListener("change", (e) => {
                    clearTimeout(sliderTimeout);
                    const newZoom = parseInt(e.target.value);
                    applyZoom(newZoom, true);
                });
            }
        }
        
        // Update slider when zoom changes
        function updateZoomSlider() {
            if (zoomSlider) {
                zoomSlider.value = Math.round(zoomLevel);
            }
            if (zoomLevelDisplay) {
                zoomLevelDisplay.textContent = Math.round(zoomLevel) + "%";
            }
        }
        
        // Initialize after page load
        setTimeout(initZoomSlider, 100);

        document.getElementById("zoomFit").addEventListener("click", () => {
            const container = document.getElementById("viewerContainer");
            const containerWidth = container.clientWidth - 40;
            const standardPageWidth = 612;
            baseScale = containerWidth / standardPageWidth;
            applyZoom(100);
            // Close menu after action
            menuOpen = false;
            menuItems.classList.remove("active");
            menuToggle.classList.remove("active");
            menuToggle.textContent = "‚ò∞";
        });

        document.getElementById("zoomReset").addEventListener("click", () => {
            baseScale = calculateScale();
            applyZoom(100);
            // Close menu after action
            menuOpen = false;
            menuItems.classList.remove("active");
            menuToggle.classList.remove("active");
            menuToggle.textContent = "‚ò∞";
        });

        // Keyboard zoom
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === "=" || e.key === "+") {
                    e.preventDefault();
                    applyZoom(zoomLevel + 25);
                } else if (e.key === "-") {
                    e.preventDefault();
                    applyZoom(zoomLevel - 25);
                } else if (e.key === "0") {
                    e.preventDefault();
                    baseScale = calculateScale();
                    applyZoom(100);
                }
            }
        });

        // ============================================
        // THUMBNAIL SIDEBAR
        // ============================================
        async function generateThumbnails() {
            const thumbnailGrid = document.getElementById("thumbnailGrid");
            thumbnailGrid.innerHTML = "";

            // On iOS, generate thumbnails lazily to save memory
            const batchSize = isIOSSafari ? 5 : 10;
            const delay = isIOSSafari ? 200 : 50;

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                // Create placeholder first
                const thumbnailItem = document.createElement("div");
                thumbnailItem.className = "thumbnail-item";
                thumbnailItem.id = `thumb-${pageNum}`;
                if (pageNum === currentPage) {
                    thumbnailItem.classList.add("active");
                }

                const placeholder = document.createElement("div");
                placeholder.style.cssText = "width:100%;height:120px;background:#2a2a2a;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px;";
                placeholder.textContent = `ÿµŸÅÿ≠ÿ© ${pageNum}`;
                thumbnailItem.appendChild(placeholder);

                const pageNumLabel = document.createElement("div");
                pageNumLabel.className = "thumbnail-page-num";
                pageNumLabel.textContent = `ÿµŸÅÿ≠ÿ© ${pageNum}`;
                thumbnailItem.appendChild(pageNumLabel);

                thumbnailItem.addEventListener("click", () => {
                    scrollToPage(pageNum);
                });

                thumbnailGrid.appendChild(thumbnailItem);

                // Generate thumbnail asynchronously
                (async (pNum) => {
                    try {
                        // Delay for iOS to prevent memory issues
                        if (pNum % batchSize === 0 && isIOSSafari) {
                            await new Promise(r => setTimeout(r, delay));
                        }

                        const page = await pdfDoc.getPage(pNum);
                        const thumbScale = isIOSSafari ? 0.15 : 0.2; // Smaller on iOS
                        const viewport = page.getViewport({ scale: thumbScale });
                        
                        const thumbCanvas = document.createElement("canvas");
                        thumbCanvas.className = "thumbnail-canvas";
                        thumbCanvas.width = viewport.width;
                        thumbCanvas.height = viewport.height;
                        
                        const ctx = thumbCanvas.getContext("2d", { alpha: false });
                        await page.render({
                            canvasContext: ctx,
                            viewport: viewport
                        }).promise;

                        // Replace placeholder with actual thumbnail
                        placeholder.replaceWith(thumbCanvas);
                    } catch (err) {
                        console.error(`Error generating thumbnail for page ${pNum}:`, err);
                        placeholder.textContent = "ÿÆÿ∑ÿ£";
                        placeholder.style.color = "#f00";
                    }
                })(pageNum);
            }
        }

        document.getElementById("toggleThumbnails").addEventListener("click", () => {
            const sidebar = document.getElementById("thumbnailSidebar");
            sidebar.classList.toggle("active");
            document.getElementById("toggleThumbnails").classList.toggle("active");
            
            if (sidebar.classList.contains("active") && thumbnailGrid.children.length === 0) {
                generateThumbnails();
            }
        });

        // Update active thumbnail on page change
        function updateActiveThumbnail() {
            document.querySelectorAll(".thumbnail-item").forEach(item => {
                item.classList.remove("active");
            });
            const activeThumb = document.getElementById(`thumb-${currentPage}`);
            if (activeThumb) {
                activeThumb.classList.add("active");
                activeThumb.scrollIntoView({ block: "nearest" });
            }
        }

        // ============================================
        // SEARCH FUNCTIONALITY
        // ============================================
        async function searchInPDF(query) {
            if (!query || !pdfDoc) return;
            
            searchResults = [];
            currentSearchIndex = -1;
            const resultsContainer = document.getElementById("searchResults");
            resultsContainer.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´...</div>';

            // On iOS, limit search to prevent memory issues
            const maxSearchPages = isIOSSafari ? 50 : pdfDoc.numPages;
            const searchDelay = isIOSSafari ? 100 : 0;

            for (let pageNum = 1; pageNum <= Math.min(maxSearchPages, pdfDoc.numPages); pageNum++) {
                try {
                    // Add delay on iOS to prevent blocking
                    if (pageNum % 10 === 0 && isIOSSafari) {
                        await new Promise(r => setTimeout(r, searchDelay));
                    }

                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const textItems = textContent.items;
                    const fullText = textItems.map(item => item.str).join(" ");
                    
                    if (fullText.toLowerCase().includes(query.toLowerCase())) {
                        const matches = [];
                        let searchIndex = 0;
                        const lowerQuery = query.toLowerCase();
                        const lowerText = fullText.toLowerCase();
                        
                        // Limit matches per page on iOS
                        const maxMatchesPerPage = isIOSSafari ? 5 : 20;
                        let matchCount = 0;
                        
                        while ((searchIndex = lowerText.indexOf(lowerQuery, searchIndex)) !== -1 && matchCount < maxMatchesPerPage) {
                            const start = Math.max(0, searchIndex - 30);
                            const end = Math.min(fullText.length, searchIndex + query.length + 30);
                            const context = fullText.substring(start, end);
                            
                            matches.push({
                                page: pageNum,
                                index: searchIndex,
                                context: context
                            });
                            searchIndex += query.length;
                            matchCount++;
                        }

                        matches.forEach(match => {
                            searchResults.push(match);
                            
                            const resultItem = document.createElement("div");
                            resultItem.className = "search-result-item";
                            resultItem.innerHTML = `
                                <div class="page-num">ÿµŸÅÿ≠ÿ© ${match.page}</div>
                                <div class="context">${match.context.replace(
                                    new RegExp(query, "gi"),
                                    `<span class="search-match">$&</span>`
                                )}</div>
                            `;
                            
                            resultItem.addEventListener("click", () => {
                                scrollToPage(match.page);
                                highlightSearchMatch(match.page, match.index);
                            });
                            
                            resultsContainer.appendChild(resultItem);
                        });
                    }
                } catch (err) {
                    console.error(`Error searching page ${pageNum}:`, err);
                }
            }

            if (searchResults.length === 0) {
                resultsContainer.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨</div>';
            } else if (isIOSSafari && maxSearchPages < pdfDoc.numPages) {
                resultsContainer.innerHTML += `<div style="color: #999; padding: 10px; text-align: center; font-size: 11px;">ÿ™ŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿ£ŸàŸÑ ${maxSearchPages} ÿµŸÅÿ≠ÿ© ŸÅŸÇÿ∑</div>`;
            }
        }

        function highlightSearchMatch(pageNum, index) {
            // Scroll to page and highlight (simplified version)
            scrollToPage(pageNum);
        }

        document.getElementById("toggleSearch").addEventListener("click", () => {
            const panel = document.getElementById("searchPanel");
            panel.classList.toggle("active");
            document.getElementById("toggleSearch").classList.toggle("active");
            if (panel.classList.contains("active")) {
                document.getElementById("searchInput").focus();
            }
        });

        let searchTimeout;
        document.getElementById("searchInput").addEventListener("input", (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchInPDF(e.target.value);
            }, 500);
        });

        // ============================================
        // FULLSCREEN MODE
        // ============================================
        function toggleFullscreen() {
            if (!isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        document.getElementById("toggleFullscreen").addEventListener("click", toggleFullscreen);

        document.addEventListener("fullscreenchange", () => {
            isFullscreen = !!document.fullscreenElement;
            document.body.classList.toggle("fullscreen", isFullscreen);
            document.getElementById("toggleFullscreen").classList.toggle("active", isFullscreen);
        });

        // ============================================
        // NIGHT MODE
        // ============================================
        document.getElementById("toggleNightMode").addEventListener("click", () => {
            isNightMode = !isNightMode;
            document.body.classList.toggle("night-mode", isNightMode);
            document.getElementById("toggleNightMode").classList.toggle("active", isNightMode);
            localStorage.setItem("pdfNightMode", isNightMode);
        });

        // Load saved night mode preference
        if (localStorage.getItem("pdfNightMode") === "true") {
            isNightMode = true;
            document.body.classList.add("night-mode");
            document.getElementById("toggleNightMode").classList.add("active");
        }

        // ============================================
        // TEXT SELECTION MODE
        // ============================================
        document.getElementById("toggleTextSelection").addEventListener("click", () => {
            textSelectionMode = !textSelectionMode;
            document.body.classList.toggle("text-selection-mode", textSelectionMode);
            document.getElementById("toggleTextSelection").classList.toggle("active", textSelectionMode);
            
            // Enable/disable text selection on text layers
            document.querySelectorAll('.textLayer').forEach(textLayer => {
                if (textSelectionMode) {
                    textLayer.style.pointerEvents = 'auto';
                    textLayer.style.userSelect = 'text';
                    textLayer.style.webkitUserSelect = 'text';
                } else {
                    textLayer.style.pointerEvents = 'auto'; // Keep enabled for text selection
                    textLayer.style.userSelect = 'text'; // Always allow text selection
                    textLayer.style.webkitUserSelect = 'text';
                }
            });
            
            if (textSelectionMode) {
                drawingMode = 'none';
                updateDrawingMode();
            }
        });

        // ============================================
        // PAGE ROTATION
        // ============================================
        document.getElementById("rotatePage").addEventListener("click", () => {
            const currentRotation = pageRotations.get(currentPage) || 0;
            const newRotation = (currentRotation + 90) % 360;
            pageRotations.set(currentPage, newRotation);
            
            const pageWrapper = pageWrappers.get(currentPage);
            if (pageWrapper) {
                pageWrapper.className = "page-wrapper";
                if (newRotation === 90) {
                    pageWrapper.classList.add("rotated-90");
                } else if (newRotation === 180) {
                    pageWrapper.classList.add("rotated-180");
                } else if (newRotation === 270) {
                    pageWrapper.classList.add("rotated-270");
                }
            }
        });

        // ============================================
        // READING STATISTICS
        // ============================================
        function updateReadingStats() {
            const readingTime = Math.floor((Date.now() - readingStartTime) / 60000);
            const progress = Math.round((pagesReadSet.size / pdfDoc.numPages) * 100);
            
            document.getElementById("pagesRead").textContent = pagesReadSet.size;
            document.getElementById("readingTime").textContent = readingTime + " ÿØŸÇŸäŸÇÿ©";
            document.getElementById("readingProgressPercent").textContent = progress + "%";
            
            // Update progress bar
            document.getElementById("readingProgress").style.width = progress + "%";
        }

        // Track pages read
        document.getElementById("viewerContainer").addEventListener("scroll", () => {
            pagesReadSet.add(currentPage);
            updateReadingStats();
        });

        document.getElementById("toggleStats").addEventListener("click", () => {
            const statsPanel = document.getElementById("statsPanel");
            statsPanel.classList.toggle("active");
            document.getElementById("toggleStats").classList.toggle("active");
            if (statsPanel.classList.contains("active")) {
                updateReadingStats();
            }
        });

        // ============================================
        // ADDITIONAL ENHANCEMENTS
        // ============================================
        
        // ============================================
        // DOUBLE TAP TO ZOOM (Enhanced - works anywhere)
        // ============================================
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;
        const DOUBLE_TAP_DELAY = 300;
        const DOUBLE_TAP_DISTANCE = 50; // Max distance between taps

        // Smart zoom levels for better UX
        const ZOOM_LEVELS = [50, 75, 100];
        
        function getNextZoomLevel(currentZoom, direction = 'in') {
            if (direction === 'in') {
                return ZOOM_LEVELS.find(level => level > currentZoom) || ZOOM_LEVELS[ZOOM_LEVELS.length - 1];
            } else {
                return [...ZOOM_LEVELS].reverse().find(level => level < currentZoom) || ZOOM_LEVELS[0];
            }
        }
        
        function handleDoubleTap(x, y) {
            const container = document.getElementById("viewerContainer");
            const containerRect = container.getBoundingClientRect();
            
            // Smart zoom: if zoomed, zoom out; if not, zoom to comfortable reading level
            let targetZoom;
            if (zoomLevel <= 100) {
                // Zoom to comfortable reading level (150% - best for reading)
                targetZoom = 150;
            } else if (zoomLevel <= 150) {
                // Zoom to detailed view (200%)
                targetZoom = 200;
            } else {
                // Zoom out to fit
                targetZoom = 100;
            }
            
            // Convert tap position to container coordinates for zoom center
            const relativeX = x - containerRect.left;
            const relativeY = y - containerRect.top;
            
            // Apply smooth zoom with center point
            applyZoom(targetZoom, true, relativeX, relativeY);
        }

        // Double tap for mobile
        if (isMobile) {
            viewerContainer.addEventListener("touchend", function handleDoubleTap(e) {
                if (e.touches.length > 0 || isPinching) return; // Don't interfere with pinch or active touches
                
                const currentTime = Date.now();
                const tapX = e.changedTouches[0].clientX;
                const tapY = e.changedTouches[0].clientY;
                
                // Check if it's a double tap
                if (currentTime - lastTapTime < DOUBLE_TAP_DELAY &&
                    Math.abs(tapX - lastTapX) < DOUBLE_TAP_DISTANCE &&
                    Math.abs(tapY - lastTapY) < DOUBLE_TAP_DISTANCE) {
                    
                    e.preventDefault();
                    handleDoubleTap(tapX, tapY);
                    lastTapTime = 0; // Reset to prevent triple tap
                } else {
                    lastTapTime = currentTime;
                    lastTapX = tapX;
                    lastTapY = tapY;
                }
            }, { passive: false });
        }

        // Double click for desktop
        viewerContainer.addEventListener("dblclick", (e) => {
            // Don't interfere with other interactions
            if (e.target.closest('#controls') || e.target.closest('#optionsMenu') || 
                e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                e.target.closest('#searchPanel')) {
                return;
            }
            
            handleDoubleTap(e.clientX, e.clientY);
        });

        // ============================================
        // PAN/DRAG FUNCTIONALITY (Move page when zoomed)
        // ============================================
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartScrollLeft = 0;
        let panStartScrollTop = 0;

        function startPan(e) {
            // Pan works at any zoom level, but more useful when zoomed
            // Don't pan if drawing or other interactions
            if (drawingMode !== 'none' || e.target.closest('.draw-canvas') ||
                e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                e.target.closest('#searchPanel') || e.target.closest('.textLayer')) {
                return;
            }

            isPanning = true;
            const container = document.getElementById("viewerContainer");
            
            if (e.touches && e.touches.length === 1) {
                // Touch
                panStartX = e.touches[0].clientX;
                panStartY = e.touches[0].clientY;
            } else {
                // Mouse
                panStartX = e.clientX;
                panStartY = e.clientY;
            }
            
            panStartScrollLeft = container.scrollLeft;
            panStartScrollTop = container.scrollTop;
            
            // Change cursor
            if (!e.touches) {
                document.body.style.cursor = 'grabbing';
            }
        }

        function doPan(e) {
            if (!isPanning) return;
            
            e.preventDefault();
            const container = document.getElementById("viewerContainer");
            
            let currentX, currentY;
            if (e.touches && e.touches.length === 1) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            
            const deltaX = panStartX - currentX;
            const deltaY = panStartY - currentY;
            
            container.scrollLeft = panStartScrollLeft + deltaX;
            container.scrollTop = panStartScrollTop + deltaY;
        }

        function endPan() {
            if (isPanning) {
                isPanning = false;
                document.body.style.cursor = '';
            }
        }

        // Mouse pan (for desktop - works at any zoom level)
        viewerContainer.addEventListener("mousedown", (e) => {
            // Allow pan at any zoom level for better control
            if (e.button === 0 && !e.target.closest('.textLayer')) { // Left mouse button, not on text layer
                startPan(e);
            }
        });

        viewerContainer.addEventListener("mousemove", (e) => {
            if (isPanning) {
                doPan(e);
            }
        });

        viewerContainer.addEventListener("mouseup", endPan);
        viewerContainer.addEventListener("mouseleave", endPan);

        // Touch pan (for mobile when zoomed) - separate handler
        if (isMobile) {
            let touchPanStartTime = 0;
            
            viewerContainer.addEventListener("touchstart", function handlePanStart(e) {
                // Pan with single touch (works at any zoom level), not during pinch
                if (e.touches.length === 1 && !isPinching && !isPanning && 
                    !e.target.closest('.textLayer') && drawingMode === 'none') {
                    touchPanStartTime = Date.now();
                    startPan(e);
                }
            }, { passive: false, capture: false });

            viewerContainer.addEventListener("touchmove", function handlePanMove(e) {
                // Only pan with single touch when zoomed
                if (e.touches.length === 1 && isPanning && !isPinching) {
                    doPan(e);
                }
            }, { passive: false, capture: false });

            viewerContainer.addEventListener("touchend", function handlePanEnd(e) {
                if (e.touches.length === 0 && isPanning) {
                    endPan();
                }
            }, { passive: true });
        }

        // ============================================
        // PINCH TO ZOOM AT TOUCH POINT (Enhanced)
        // ============================================
        let lastTouchDistance = 0;
        let initialZoomLevel = 100;
        let isPinching = false;
        let pinchStartX = 0;
        let pinchStartY = 0;
        let lastZoomTime = 0;
        const ZOOM_THROTTLE = 50; // Throttle zoom updates to 50ms

        // Separate pinch zoom handler - must be registered before other touch handlers
        const viewerContainer = document.getElementById("viewerContainer");
        
        // Pinch zoom touchstart
        viewerContainer.addEventListener("touchstart", function handlePinchStart(e) {
            // Only handle 2-finger touch
            if (e.touches.length === 2) {
                // Don't interfere with drawing
                if (drawingMode !== 'none' && e.target.closest('.draw-canvas')) {
                    return;
                }
                
                isPinching = true;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point of pinch
                pinchStartX = (touch1.clientX + touch2.clientX) / 2;
                pinchStartY = (touch1.clientY + touch2.clientY) / 2;
                
                // Get initial distance
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Store initial zoom level
                initialZoomLevel = zoomLevel;
            } else {
                isPinching = false;
                lastTouchDistance = 0;
            }
        }, { passive: true, capture: true });

        // Pinch zoom touchmove
        viewerContainer.addEventListener("touchmove", function handlePinchMove(e) {
            if (e.touches.length === 2 && isPinching && lastTouchDistance > 0) {
                // Don't interfere with drawing
                if (drawingMode !== 'none' && e.target.closest('.draw-canvas')) {
                    return;
                }
                
                // Throttle zoom updates
                const now = Date.now();
                if (now - lastZoomTime < ZOOM_THROTTLE) {
                    return;
                }
                lastZoomTime = now;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate zoom change based on distance ratio
                const distanceRatio = currentDistance / lastTouchDistance;
                
                // Calculate new zoom level
                let newZoom = initialZoomLevel * distanceRatio;
                
                // Limit zoom: 50% minimum, 200% maximum for all devices
                const maxZoom = 200;
                const minZoom = 50;
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                
                // Get container for scroll calculations
                const container = document.getElementById("viewerContainer");
                const containerRect = container.getBoundingClientRect();
                
                // Calculate current center point
                const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
                const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                // Convert touch center to container coordinates (relative to viewport)
                const relativeX = currentCenterX - containerRect.left;
                const relativeY = currentCenterY - containerRect.top;
                
                // Apply zoom with center point (no animation for pinch - instant feedback)
                applyZoom(newZoom, false, relativeX, relativeY);
                
                // Update last distance for next calculation
                lastTouchDistance = currentDistance;
                initialZoomLevel = newZoom; // Update base for continuous zoom
            }
        }, { passive: true, capture: true });

        // Pinch zoom touchend
        viewerContainer.addEventListener("touchend", function handlePinchEnd(e) {
            if (e.touches.length < 2) {
                isPinching = false;
                lastTouchDistance = 0;
            }
        }, { passive: true, capture: true });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
            if (e.target.tagName === "INPUT") return;
            
            switch(e.key) {
                case "ArrowRight":
                case "ArrowDown":
                    e.preventDefault();
                    if (pdfDoc && currentPage < pdfDoc.numPages) {
                        scrollToPage(currentPage + 1);
                    }
                    break;
                case "ArrowLeft":
                case "ArrowUp":
                    e.preventDefault();
                    if (pdfDoc && currentPage > 1) {
                        scrollToPage(currentPage - 1);
                    }
                    break;
                case "Home":
                    e.preventDefault();
                    scrollToPage(1);
                    break;
                case "End":
                    e.preventDefault();
                    if (pdfDoc) scrollToPage(pdfDoc.numPages);
                    break;
                case "f":
                case "F":
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        toggleFullscreen();
                    }
                    break;
                case "Escape":
                    if (isFullscreen) {
                        toggleFullscreen();
                    }
                    break;
            }
        });

        // Initialize zoom level display
        document.getElementById("zoomLevel").textContent = zoomLevel + "%";
        
        // ============================================
        // iOS-SPECIFIC OPTIMIZATIONS
        // ============================================
        if (isIOSSafari) {
            // Disable heavy features on iOS
            document.getElementById("toggleThumbnails").style.display = "none"; // Hide thumbnails on iOS initially
            document.getElementById("toggleSearch").style.display = "none"; // Hide search on iOS initially
            
            // Reduce animation complexity
            document.documentElement.style.setProperty('--transition-speed', '0.2s');
            
            // Add memory warning handler
            window.addEventListener("beforeunload", () => {
                // Clean up canvases
                drawCanvases.forEach(canvas => {
                    if (canvas && canvas.width) {
                        canvas.width = 0;
                        canvas.height = 0;
                    }
                });
            });

            // Periodic memory cleanup on iOS
            setInterval(() => {
                if (renderedPages.size > 10) {
                    // Keep only recent 10 pages in memory
                    const pagesArray = Array.from(renderedPages).sort((a, b) => b - a);
                    const pagesToRemove = pagesArray.slice(10);
                    
                    pagesToRemove.forEach(pageNum => {
                        const wrapper = pageWrappers.get(pageNum);
                        if (wrapper && Math.abs(pageNum - currentPage) > 5) {
                            // Remove canvas data but keep wrapper
                            const canvas = drawCanvases.get(pageNum);
                            if (canvas) {
                                const ctx = canvas.getContext("2d");
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                            }
                            renderedPages.delete(pageNum);
                        }
                    });
                }
            }, 30000); // Every 30 seconds
        }
    </script>

</body>
</html>