<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Secure PDF Viewer</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: #1a1a1a;
            color: white;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow text selection in text layers */
        .textLayer, .textLayer * {
            -webkit-user-select: text !important;
            user-select: text !important;
            -moz-user-select: text !important;
        }

        #viewerContainer {
            width: 100%;
            height: 100vh;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            overflow-x: auto; /* Allow horizontal scroll when zoomed */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 80px 20px 20px;
            position: relative;
        }

        /* Enable horizontal scroll when zoomed */
        #viewerContainer.zoomed {
            overflow-x: auto;
            align-items: flex-start; /* Align to left when zoomed for better scrolling */
        }

        .page-wrapper {
            position: relative;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            background: #2a2a2a;
            border-radius: 8px;
            transform-origin: center top;
            transition: transform 0.2s ease;
            /* Allow horizontal scroll when zoomed */
            overflow: visible;
            min-width: fit-content;
        }

        /* When zoomed, allow horizontal scrolling */
        .page-wrapper.zoomed {
            overflow-x: auto;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
        }

        /* Ensure text layer is selectable */
        .page-wrapper .textLayer {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
        }

        .pdf-canvas {
            margin: 0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-width: 100%;
            display: block;
            background: white;
            image-rendering: -webkit-optimize-contrast;
        }

        /* Text Layer Container */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            text-align: initial;
            pointer-events: auto;
            transform-origin: 0% 0%;
            z-index: 2;
        }

        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
        }

        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgba(255, 235, 59, 0.3);
            border-radius: 2px;
        }

        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 255, 0.3);
        }

        .draw-canvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            border-radius: 8px;
            z-index: 3; /* Above text layer */
        }

        .draw-canvas.no-drawing {
            pointer-events: none;
        }

        .draw-canvas.pen-mode,
        .draw-canvas.eraser-mode {
            touch-action: none;
        }

        .draw-canvas.pen-mode {
            cursor: crosshair;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 9999;
            font-size: 22px;
            text-align: center;
            font-weight: 600;
            background: rgba(0,0,0,0.8);
            padding: 30px 50px;
            border-radius: 12px;
        }

        #loader #percent {
            display: block;
            margin-top: 10px;
            font-size: 16px;
            color: #aaa;
        }

        #controls {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(0,0,0,0.85);
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: opacity 0.3s ease, transform 0.3s ease;
            flex-wrap: wrap;
            max-width: 90vw;
        }

        #controls.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(-10px);
        }

        /* Auto-hide controls on mobile after inactivity */
        #controls.auto-hide {
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        #controls button {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 8px;
            border: none;
            background: #3d5a80;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
            -webkit-touch-callout: none;
        }

        #controls button:hover {
            background: #2c4458;
        }

        #controls button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #controls #pageInfo {
            padding: 0 12px;
            font-size: 14px;
            color: #ccc;
            white-space: nowrap;
        }

        #controls input {
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid #555;
            background: #2a2a2a;
            color: white;
            width: 70px;
        }

        #optionsMenu {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 10001;
        }

        #menuToggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3d5a80, #2c4458);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-touch-callout: none;
        }

        #menuToggle:active {
            transform: scale(0.95);
        }

        #menuToggle.active {
            transform: rotate(45deg);
        }

        #menuItems {
            position: absolute;
            bottom: 80px;
            right: 0;
            background: rgba(0,0,0,0.9);
            border-radius: 12px;
            padding: 10px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            opacity: 0;
            transform: translateY(20px) scale(0.9);
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #menuItems.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .menu-item {
            padding: 12px 16px;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            margin: 4px 0;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            -webkit-touch-callout: none;
        }

        .menu-item:active {
            background: rgba(61, 90, 128, 0.3);
        }

        .menu-item.active {
            background: rgba(61, 90, 128, 0.5);
        }

        .menu-item-icon {
            width: 20px;
            text-align: center;
        }

        /* Zoom Slider Styles */
        #zoomSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #2a2a2a;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3d5a80;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        #zoomSlider::-webkit-slider-thumb:hover {
            background: #5a7ba8;
        }

        #zoomSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3d5a80;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }

        #zoomSlider::-moz-range-thumb:hover {
            background: #5a7ba8;
        }

        /* Pan cursor when zoomed */
        body.pan-mode {
            cursor: grab;
        }

        body.pan-mode:active {
            cursor: grabbing;
        }

        /* ============================================
           ZOOM CONTROLS
        ============================================ */
        /* Zoom controls moved to menu - hide the separate zoom controls */
        #zoomControls {
            display: none;
        }

        /* ============================================
           THUMBNAIL SIDEBAR
        ============================================ */
        #thumbnailSidebar {
            position: fixed;
            left: -300px;
            top: 0;
            width: 280px;
            height: 100vh;
            background: rgba(26, 26, 26, 0.98);
            z-index: 10003;
            transition: left 0.3s ease;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0,0,0,0.5);
            padding: 80px 10px 20px;
        }

        #thumbnailSidebar.active {
            left: 0;
        }

        #thumbnailSidebar h3 {
            color: white;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid #444;
        }

        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
        }

        .thumbnail-item {
            background: #2a2a2a;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            border: 2px solid transparent;
        }

        .thumbnail-item:hover {
            transform: scale(1.05);
            background: #3a3a3a;
        }

        .thumbnail-item.active {
            border-color: #3d5a80;
            background: #3a3a3a;
        }

        .thumbnail-canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            background: white;
        }

        .thumbnail-page-num {
            text-align: center;
            color: #ccc;
            font-size: 11px;
            margin-top: 4px;
        }

        /* ============================================
           SEARCH PANEL
        ============================================ */
        #searchPanel {
            position: fixed;
            top: 70px;
            right: -400px;
            width: 350px;
            background: rgba(26, 26, 26, 0.98);
            z-index: 10004;
            transition: right 0.3s ease;
            box-shadow: -4px 0 20px rgba(0,0,0,0.5);
            border-radius: 12px 0 0 12px;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #searchPanel.active {
            right: 0;
        }

        #searchInput {
            width: 100%;
            padding: 12px;
            border: 2px solid #3d5a80;
            border-radius: 8px;
            background: #2a2a2a;
            color: white;
            font-size: 14px;
            margin-bottom: 15px;
        }

        #searchInput:focus {
            outline: none;
            border-color: #5a7ba8;
        }

        .search-results {
            margin-top: 15px;
        }

        .search-result-item {
            padding: 10px;
            margin: 5px 0;
            background: #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: #3a3a3a;
        }

        .search-result-item .page-num {
            color: #3d5a80;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .search-result-item .context {
            color: #ccc;
            font-size: 12px;
        }

        .search-match {
            background: #ffeb3b;
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* ============================================
           FULLSCREEN MODE
        ============================================ */
        body.fullscreen {
            overflow: hidden;
        }

        body.fullscreen #viewerContainer {
            padding: 0;
            height: 100vh;
        }

        body.fullscreen #controls,
        body.fullscreen #optionsMenu {
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        body.fullscreen #controls:hover,
        body.fullscreen #optionsMenu:hover {
            opacity: 1;
        }

        /* ============================================
           NIGHT MODE
        ============================================ */
        body.night-mode {
            background: #0a0a0a;
        }

        body.night-mode .page-wrapper {
            background: #1a1a1a;
        }

        body.night-mode .pdf-canvas {
            filter: invert(1) hue-rotate(180deg);
        }

        /* ============================================
           TEXT SELECTION
        ============================================ */
        .text-selection-mode body {
            -webkit-user-select: text;
            user-select: text;
        }

        .text-selection-mode .pdf-canvas {
            cursor: text;
        }

        .highlight {
            position: absolute;
            background: rgba(255, 235, 59, 0.4);
            border-radius: 2px;
            pointer-events: none;
        }

        /* ============================================
           READING PROGRESS
        ============================================ */
        #readingProgress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #3d5a80, #5a7ba8);
            z-index: 10005;
            transition: width 0.3s ease;
        }

        /* ============================================
           STATISTICS PANEL
        ============================================ */
        #statsPanel {
            position: fixed;
            bottom: 100px;
            left: 30px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            z-index: 10006;
            font-size: 12px;
            color: #ccc;
            min-width: 200px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #statsPanel.active {
            opacity: 1;
            pointer-events: all;
        }

        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #3d5a80;
            font-weight: 600;
        }


        /* ============================================
           PAGE ROTATION
        ============================================ */
        .page-wrapper.rotated-90 {
            transform: rotate(90deg);
        }

        .page-wrapper.rotated-180 {
            transform: rotate(180deg);
        }

        .page-wrapper.rotated-270 {
            transform: rotate(-90deg);
        }

        @media (max-width: 768px) {
            #optionsMenu {
                bottom: 20px;
                right: 20px;
            }

            #menuToggle {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            #menuItems {
                min-width: 180px;
                bottom: 70px;
            }

            #controls {
                gap: 8px;
                padding: 10px 15px;
            }

            #controls button {
                padding: 6px 12px;
                font-size: 12px;
            }

            #controls input {
                width: 60px;
                padding: 6px 8px;
            }

            #viewerContainer {
                padding: 100px 10px 20px;
            }

            .page-wrapper {
                margin: 12px 0;
            }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body oncontextmenu="return false">

    <div id="controls" class="hidden">
        <button id="prevBtn">‚ü∏</button>
        <span id="pageInfo">Page 1 / ?</span>
        <button id="nextBtn">‚üπ</button>
        <input type="number" id="jumpPage" min="1" placeholder="Go to" />
        <button id="goBtn">Go</button>
    </div>

    <!-- Reading Progress Bar -->
    <div id="readingProgress"></div>

    <!-- Thumbnail Sidebar -->
    <div id="thumbnailSidebar">
        <h3>üìë ÿßŸÑÿµŸÅÿ≠ÿßÿ™</h3>
        <div class="thumbnail-grid" id="thumbnailGrid"></div>
    </div>

    <!-- Search Panel -->
    <div id="searchPanel">
        <h3 style="color: white; margin-bottom: 15px;">üîç ÿßŸÑÿ®ÿ≠ÿ´</h3>
        <input type="text" id="searchInput" placeholder="ÿßÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÜÿµ...">
        <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Statistics Panel -->
    <div id="statsPanel">
        <div class="stat-item">
            <span class="stat-label">ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©:</span>
            <span class="stat-value" id="pagesRead">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">ŸàŸÇÿ™ ÿßŸÑŸÇÿ±ÿßÿ°ÿ©:</span>
            <span class="stat-value" id="readingTime">0 ÿØŸÇŸäŸÇÿ©</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">ÿßŸÑÿ™ŸÇÿØŸÖ:</span>
            <span class="stat-value" id="readingProgressPercent">0%</span>
        </div>
    </div>

    <!-- Zoom Controls - Moved to menu -->
    <div id="zoomControls" style="display: none;">
        <div id="zoomLevel">100%</div>
    </div>


    <div id="optionsMenu">
        <button id="menuToggle">‚ò∞</button>
        <div id="menuItems">
            <div class="menu-item" id="toggleNav">
                <span class="menu-item-icon">üß≠</span>
                <span>Navigation</span>
            </div>
            <div class="menu-item" id="toggleThumbnails">
                <span class="menu-item-icon">üìë</span>
                <span>Thumbnails</span>
            </div>
            <div class="menu-item" id="toggleSearch">
                <span class="menu-item-icon">üîç</span>
                <span>Search</span>
            </div>
            <div class="menu-item" id="toggleFullscreen">
                <span class="menu-item-icon">‚õ∂</span>
                <span>Fullscreen</span>
            </div>
            <div class="menu-item" id="toggleNightMode">
                <span class="menu-item-icon">üåô</span>
                <span>Night Mode</span>
            </div>
            <div class="menu-item" id="toggleTextSelection">
                <span class="menu-item-icon">üìù</span>
                <span>Text Selection</span>
            </div>
            <div class="menu-item" id="penTool">
                <span class="menu-item-icon">‚úèÔ∏è</span>
                <span>Pen</span>
            </div>
            <div class="menu-item" id="eraserTool">
                <span class="menu-item-icon">üßπ</span>
                <span>Eraser</span>
            </div>
            <div class="menu-item" id="rotatePage">
                <span class="menu-item-icon">üîÑ</span>
                <span>Rotate</span>
            </div>
            <div class="menu-item" id="zoomControlItem" style="flex-direction: column; align-items: stretch; gap: 8px; padding: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 12px; color: #ccc;">Zoom Level</span>
                    <span id="zoomLevelDisplay" style="font-size: 14px; color: #3d5a80; font-weight: 600;">100%</span>
                </div>
                <input type="range" id="zoomSlider" min="50" max="400" value="100" step="10" 
                       style="width: 100%; height: 6px; background: #2a2a2a; border-radius: 3px; outline: none; cursor: pointer;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 4px;">
                    <span>50%</span>
                    <span>200%</span>
                    <span>400%</span>
                </div>
            </div>
            <div class="menu-item" id="zoomFit">
                <span class="menu-item-icon">‚õ∂</span>
                <span>Fit to Screen</span>
            </div>
            <div class="menu-item" id="zoomReset">
                <span class="menu-item-icon">‚Ü∫</span>
                <span>Reset Zoom</span>
            </div>
            <div class="menu-item" id="toggleStats">
                <span class="menu-item-icon">üìä</span>
                <span>Statistics</span>
            </div>
        </div>
    </div>

    <div id="loader">
        Loading PDF...
        <div id="percent">0%</div>
    </div>

    <div id="viewerContainer"></div>

    <script>
        // Device detection
        const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        const isLowEndDevice = window.deviceMemory <= 4 || navigator.hardwareConcurrency <= 2;
        
        document.onkeydown = function (e) {
            if (e.ctrlKey && ["s", "S", "p", "P", "u", "U"].includes(e.key)) {
                e.preventDefault();
            }
        };

        const params = new URLSearchParams(window.location.search);
        const id = params.get("id");

        if (!id) {
            document.getElementById("loader").innerText = "Invalid File ID";
            throw new Error("Missing id");
        }

        const BASE_URL = 'https://diaaapi.premiumasp.net/api';
        const url = `${BASE_URL}/Summary/${id}/file`;

        async function trackVisit(summaryId) {
            try {
                await fetch(`${BASE_URL}/Summary/${summaryId}/visit`, {
                    method: 'POST',
                    headers: {
                        'accept': '*/*',
                        'Content-Type': 'application/json'
                    }
                });
            } catch (err) {
                console.error('Error tracking visit:', err);
            }
        }

        trackVisit(id);
        
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

        function calculateScale() {
            const container = document.getElementById("viewerContainer");
            let containerWidth = window.innerWidth;
            
            if (container) {
                containerWidth = container.clientWidth;
            }
            
            const padding = window.innerWidth <= 768 ? 20 : 40;
            const availableWidth = containerWidth - padding;
            const standardPageWidth = 612;
            
            let scale = availableWidth / standardPageWidth;
            
            // Enhanced scale for high resolution rendering
            // iOS: More conservative to maintain performance
            if (isIOSSafari) {
                scale = Math.min(scale, 1.5); // Conservative: 1.5 for iOS (was 1.0, increased to 1.5)
            } else if (isAndroid) {
                scale = Math.min(scale, 2.2); // Increased from 1.1 to 2.2
            } else if (window.innerWidth > 1024) {
                scale = Math.min(scale, 3.0); // Increased from 1.8 to 3.0
            } else if (window.innerWidth > 768) {
                scale = Math.min(scale, 2.5); // Added for tablets
            }
            
            return Math.max(scale, 1.0); // Increased minimum from 0.6 to 1.0
        }

        let scale = calculateScale();
        let baseScale = scale;
        let pdfDoc = null;
        let currentPage = 1;
        let drawingMode = 'none';
        let drawCanvases = new Map();
        let pageWrappers = new Map();
        let renderedPages = new Set();
        let pagePromises = new Map();
        let activeRendering = 0;
        
        // Advanced features state
        let zoomLevel = 100;
        let isFullscreen = false;
        let isNightMode = false;
        let textSelectionMode = false;
        let pageRotations = new Map(); // Store rotation for each page
        let readingStartTime = Date.now();
        let pagesReadSet = new Set();
        let searchResults = [];
        let currentSearchIndex = -1;
        
        // Smart rendering based on device - Enhanced for high resolution
        let maxConcurrentRenders = 1;
        let pixelRatio = window.devicePixelRatio || 1;
        let maxImageSize = 512 * 512;
        
        // Increase pixel ratio for high resolution rendering
        // iOS: More conservative to avoid memory issues
        if (isIOSSafari) {
            maxConcurrentRenders = 1;
            pixelRatio = Math.min(Math.max(pixelRatio, 1.5), 2.0); // Conservative: 1.5-2.0 for iOS
            maxImageSize = 768 * 768; // Moderate increase for iOS
        } else if (isAndroid || isLowEndDevice) {
            maxConcurrentRenders = 1;
            pixelRatio = Math.max(pixelRatio, 2.0); // Increased from 1.5 to 2.0
            maxImageSize = 1024 * 1024; // Increased from 768*768
        } else if (isMobile) {
            maxConcurrentRenders = 2;
            pixelRatio = Math.max(pixelRatio, 2.5); // Increased from 1.5 to 2.5
            maxImageSize = 1536 * 1536; // Increased from 1024*1024
        } else {
            // Desktop - High resolution
            maxConcurrentRenders = 3;
            pixelRatio = Math.max(pixelRatio, 3.0); // Increased from 2.0 to 3.0 for ultra high res
            maxImageSize = 4096 * 4096; // Increased from 2048*2048
        }
        
        const loadingTask = pdfjsLib.getDocument({
            url: url,
            disableAutoFetch: false,
            disableStream: false,
            disableRange: false,
            maxImageSize: maxImageSize,
            isEvalSupported: false,
            useSystemFonts: isIOSSafari
        });

        loadingTask.onProgress = function (progress) {
            if (progress.total) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById("percent").innerText = percent + "%";
            }
        };

        loadingTask.promise.then(async (pdf) => {
            pdfDoc = pdf;
            await initializeLazyLoading();
            updateDrawingMode();
            setupNavigation();
            document.getElementById("loader").style.display = "none";
            updatePageInfo();
            updateReadingStats();
            
            // Initialize base scale
            baseScale = calculateScale();
            applyZoom(100);
        }).catch(err => {
            console.error("PDF.js Error:", err);
            document.getElementById("loader").innerHTML = "Failed to load PDF.<br>Please try again or use desktop.";
        });

        async function initializeLazyLoading() {
            const viewer = document.getElementById("viewerContainer");
            viewer.innerHTML = "";
            drawCanvases.clear();
            pageWrappers.clear();
            renderedPages.clear();
            pagePromises.clear();

            scale = calculateScale();

            // Create all page wrappers as placeholders
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.createElement("div");
                pageWrapper.className = "page-wrapper";
                pageWrapper.id = `page-${pageNum}`;
                pageWrapper.style.minHeight = "600px";
                viewer.appendChild(pageWrapper);
                pageWrappers.set(pageNum, pageWrapper);
            }

            // Render first page immediately
            await renderPage(1);
            if (pdfDoc.numPages > 1) await renderPage(2);

            // Setup intersection observer for lazy loading
            setupIntersectionObserver();
        }

        async function renderPage(pageNum) {
            if (renderedPages.has(pageNum)) return;
            if (pagePromises.has(pageNum)) return pagePromises.get(pageNum);

            const renderPromise = (async () => {
                // Wait if too many renders happening
                while (activeRendering >= maxConcurrentRenders) {
                    await new Promise(r => setTimeout(r, 50));
                }

                activeRendering++;
                
                try {
                    if (renderedPages.has(pageNum)) return;

                    const page = await pdfDoc.getPage(pageNum);
                    // Always use baseScale for viewport - zoom is handled by CSS transform
                    const viewport = page.getViewport({ scale: baseScale });

                    const pageWrapper = pageWrappers.get(pageNum);
                    if (!pageWrapper) return;

                    pageWrapper.innerHTML = "";
                    pageWrapper.style.minHeight = "";
                
                const pdfCanvas = document.createElement("canvas");
                pdfCanvas.className = "pdf-canvas";
                
                    // High resolution canvas rendering
                    pdfCanvas.width = Math.floor(viewport.width * pixelRatio);
                    pdfCanvas.height = Math.floor(viewport.height * pixelRatio);
                pdfCanvas.style.width = viewport.width + "px";
                pdfCanvas.style.height = viewport.height + "px";

                    const ctx = pdfCanvas.getContext("2d", { alpha: false });
                    ctx.scale(pixelRatio, pixelRatio);
                
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;

                // Create text layer container
                const textLayerDiv = document.createElement("div");
                textLayerDiv.className = "textLayer";
                textLayerDiv.style.width = viewport.width + "px";
                textLayerDiv.style.height = viewport.height + "px";
                textLayerDiv.style.left = "50%";
                textLayerDiv.style.transform = "translateX(-50%)";
                textLayerDiv.style.position = "absolute";
                textLayerDiv.style.top = "0";

                // Render text layer for selectable text
                const textContent = await page.getTextContent();
                const textItems = textContent.items;
                
                // On iOS, limit text items to prevent performance issues
                const maxTextItems = isIOSSafari ? 500 : textItems.length;
                const itemsToRender = textItems.slice(0, maxTextItems);
                
                // Create text layer using PDF.js text layer rendering
                // This creates selectable, searchable text overlays
                for (let i = 0; i < itemsToRender.length; i++) {
                    const textItem = itemsToRender[i];
                    
                    // Transform coordinates from PDF space to viewport space
                    // textItem.transform is [a, b, c, d, e, f] where:
                    // - [a, b, c, d] is the transformation matrix
                    // - [e, f] is the translation
                    const transform = textItem.transform;
                    const scaleX = Math.hypot(transform[0], transform[1]);
                    const scaleY = Math.hypot(transform[2], transform[3]);
                    const angle = Math.atan2(transform[1], transform[0]);
                    
                    // Calculate position in viewport coordinates
                    const tx = transform[4];
                    const ty = transform[5];
                    
                    // Create text span element
                    const textDiv = document.createElement("span");
                    textDiv.textContent = textItem.str;
                    
                    // Position the text span (PDF coordinates are bottom-up, CSS is top-down)
                    textDiv.style.left = tx + "px";
                    textDiv.style.top = (viewport.height - ty) + "px";
                    textDiv.style.fontSize = scaleY + "px";
                    textDiv.style.fontFamily = textItem.fontName || "sans-serif";
                    textDiv.style.width = (textItem.width || scaleX * textItem.str.length) + "px";
                    textDiv.style.height = scaleY + "px";
                    
                    // Apply rotation if needed
                    if (Math.abs(angle) > 0.001) {
                        textDiv.style.transform = `rotate(${angle}rad)`;
                        textDiv.style.transformOrigin = "0% 0%";
                    }
                    
                    // Style for text selection
                    textDiv.style.position = "absolute";
                    textDiv.style.whiteSpace = "pre";
                    textDiv.style.cursor = "text";
                    textDiv.style.color = "transparent";
                    textDiv.style.userSelect = "text";
                    textDiv.style.webkitUserSelect = "text";
                    textDiv.style.mozUserSelect = "text";
                    textDiv.style.msUserSelect = "text";
                    textDiv.style.lineHeight = "1.0";
                    textDiv.style.overflow = "hidden";
                    
                    // Add to text layer
                    textLayerDiv.appendChild(textDiv);
                }

                const drawCanvas = document.createElement("canvas");
                drawCanvas.className = "draw-canvas";
                
                    drawCanvas.width = Math.floor(viewport.width * pixelRatio);
                    drawCanvas.height = Math.floor(viewport.height * pixelRatio);
                drawCanvas.style.width = viewport.width + "px";
                drawCanvas.style.height = viewport.height + "px";
                
                const drawCtx = drawCanvas.getContext("2d");
                    drawCtx.scale(pixelRatio, pixelRatio);

                // Append elements in correct z-order: canvas (bottom), text layer (middle), draw canvas (top)
                pageWrapper.appendChild(pdfCanvas);
                pageWrapper.appendChild(textLayerDiv);
                pageWrapper.appendChild(drawCanvas);

                // Store base dimensions for zoom
                pageWrapper.dataset.baseWidth = viewport.width + "";
                pageWrapper.dataset.baseHeight = viewport.height + "";

                // Apply current zoom level using CSS transform
                const currentZoomFactor = zoomLevel / 100;
                pageWrapper.style.transform = `scale(${currentZoomFactor})`;
                pageWrapper.style.transformOrigin = "center top";
                
                // Enable horizontal scroll when zoomed
                if (zoomLevel > 100) {
                    pageWrapper.classList.add("zoomed");
                    pageWrapper.style.minWidth = (viewport.width * currentZoomFactor) + "px";
                }

                    drawCanvases.set(pageNum, drawCanvas);
                enableDrawing(drawCanvas);
                    renderedPages.add(pageNum);

                    // Clean up memory on iOS periodically
                    if (isIOSSafari && pageNum % 5 === 0) {
                        await new Promise(r => setTimeout(r, 100));
                    }
                } catch (err) {
                    console.error(`Error rendering page ${pageNum}:`, err);
                    const pageWrapper = pageWrappers.get(pageNum);
                    if (pageWrapper) {
                        pageWrapper.innerHTML = '<div style="text-align:center;padding:20px;color:#f00;">Error</div>';
                    }
                } finally {
                    activeRendering--;
                    pagePromises.delete(pageNum);
                }
            })();

            pagePromises.set(pageNum, renderPromise);
            return renderPromise;
        }

        function setupIntersectionObserver() {
            if (!('IntersectionObserver' in window)) return;

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.id.replace('page-', ''));
                        renderPage(pageNum);
                        // Pre-render next page
                        if (pageNum < pdfDoc.numPages) {
                            renderPage(pageNum + 1);
                        }
                    }
                });
            }, {
                rootMargin: '300px'
            });

            pageWrappers.forEach(wrapper => observer.observe(wrapper));
        }

        function enableDrawing(canvas) {
            const ctx = canvas.getContext("2d");
            let drawing = false;

            function getCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function startDrawing(e) {
                if (drawingMode === 'none') return;
                e.preventDefault();
                drawing = true;
                const coords = getCoordinates(e);
                ctx.beginPath();
                ctx.moveTo(coords.x, coords.y);
            }

            function draw(e) {
                if (!drawing || drawingMode === 'none') return;
                e.preventDefault();
                const coords = getCoordinates(e);

                if (drawingMode === 'pen') {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = '#ffeb3b';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                } else if (drawingMode === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = 20;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                }

                    ctx.lineTo(coords.x, coords.y);
                    ctx.stroke();
            }

            function stopDrawing(e) {
                drawing = false;
                ctx.beginPath();
            }

            canvas.addEventListener("mousedown", startDrawing, false);
            canvas.addEventListener("mousemove", draw, false);
            canvas.addEventListener("mouseup", stopDrawing, false);
            canvas.addEventListener("mouseleave", stopDrawing, false);

            canvas.addEventListener("touchstart", startDrawing, { passive: false });
            canvas.addEventListener("touchmove", draw, { passive: false });
            canvas.addEventListener("touchend", stopDrawing, { passive: false });
            canvas.addEventListener("touchcancel", stopDrawing, { passive: false });
        }

        function updateDrawingMode() {
            drawCanvases.forEach(canvas => {
                canvas.className = "draw-canvas";
                if (drawingMode === 'pen') {
                    canvas.classList.add('pen-mode');
                } else if (drawingMode === 'eraser') {
                    canvas.classList.add('eraser-mode');
                } else {
                    canvas.classList.add('no-drawing');
                }
            });
        }

        async function scrollToPage(pageNum) {
            if (!pdfDoc || pageNum < 1 || pageNum > pdfDoc.numPages) return;
            
            if (!renderedPages.has(pageNum)) {
                await renderPage(pageNum);
            }
            
            const pageElement = pageWrappers.get(pageNum);
            if (pageElement) {
                const container = document.getElementById("viewerContainer");
                
                // Smooth scroll to page center - improved navigation
                const containerRect = container.getBoundingClientRect();
                const pageRect = pageElement.getBoundingClientRect();
                const scrollTop = container.scrollTop + pageRect.top - containerRect.top - (containerRect.height / 2) + (pageRect.height / 2);
                
                container.scrollTo({
                    top: Math.max(0, scrollTop),
                    behavior: 'smooth'
                });
                
                currentPage = pageNum;
                updatePageInfo();
            }
        }

        function updatePageInfo() {
            const pageInfo = document.getElementById("pageInfo");
            if (pageInfo && pdfDoc) {
                pageInfo.textContent = `Page ${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        let scrollTimeout;
        document.getElementById("viewerContainer").addEventListener("scroll", () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const container = document.getElementById("viewerContainer");
                const centerY = container.clientHeight / 2;

                pageWrappers.forEach((wrapper, pageNum) => {
                    const rect = wrapper.getBoundingClientRect();
                    const wrapperCenter = rect.top + rect.height / 2;
                    const distance = Math.abs(wrapperCenter - centerY);

                    if (distance < container.clientHeight / 2) {
                        currentPage = pageNum;
                    }
                });

                updatePageInfo();
                updateActiveThumbnail();
                updateReadingStats();
            }, 150);
        });

        function setupNavigation() {
            document.getElementById("nextBtn").onclick = () => {
                    if (pdfDoc && currentPage < pdfDoc.numPages) {
                        scrollToPage(currentPage + 1);
                    }
                };

            document.getElementById("prevBtn").onclick = () => {
                    if (pdfDoc && currentPage > 1) {
                        scrollToPage(currentPage - 1);
                    }
                };

            document.getElementById("goBtn").onclick = () => {
                const p = parseInt(document.getElementById("jumpPage").value);
                if (pdfDoc && p >= 1 && p <= pdfDoc.numPages) {
                        scrollToPage(p);
                    document.getElementById("jumpPage").value = "";
                    }
                };

            document.getElementById("jumpPage").addEventListener("keypress", (e) => {
                    if (e.key === "Enter") {
                    document.getElementById("goBtn").click();
                }
            });
        }

        const menuToggle = document.getElementById("menuToggle");
        const menuItems = document.getElementById("menuItems");
        let menuOpen = false;

        menuToggle.addEventListener("click", () => {
            menuOpen = !menuOpen;
            menuItems.classList.toggle("active", menuOpen);
            menuToggle.classList.toggle("active", menuOpen);
            menuToggle.textContent = menuOpen ? "‚úï" : "‚ò∞";
        });

        document.getElementById("toggleNav").addEventListener("click", () => {
            const controls = document.getElementById("controls");
            controls.classList.toggle("hidden");
            document.getElementById("toggleNav").classList.toggle("active");
        });

        // ============================================
        // TOUCH TO TOGGLE CONTROLS (Mobile)
        // ============================================
        let controlsAutoHideTimeout = null;
        let lastTouchTime = 0;
        let touchStartY = 0;
        let touchStartX = 0;
        const TOUCH_DELAY = 300; // Delay to distinguish tap from scroll/draw
        const SWIPE_THRESHOLD = 30; // Minimum distance for swipe

        function showControls() {
            const controls = document.getElementById("controls");
            controls.classList.remove("hidden");
            controls.classList.add("auto-hide");
            
            // Clear existing timeout
            if (controlsAutoHideTimeout) {
                clearTimeout(controlsAutoHideTimeout);
            }
            
            // Auto-hide after 3 seconds on mobile
            if (isMobile) {
                controlsAutoHideTimeout = setTimeout(() => {
                    if (!controls.classList.contains("hidden")) {
                        controls.classList.add("hidden");
                    }
                }, 3000);
            }
        }

        function hideControls() {
            const controls = document.getElementById("controls");
            controls.classList.add("hidden");
            if (controlsAutoHideTimeout) {
                clearTimeout(controlsAutoHideTimeout);
            }
        }

        function toggleControls() {
            const controls = document.getElementById("controls");
            if (controls.classList.contains("hidden")) {
                showControls();
            } else {
                hideControls();
            }
        }

        // Touch event handlers for mobile - Toggle controls with tap
        if (isMobile) {
            const viewerContainer = document.getElementById("viewerContainer");
            let touchStartTime = 0;
            let touchMoved = false;
            let touchStartX = 0;
            let touchStartY = 0;

            // Separate touch handler for controls toggle (single finger only)
            viewerContainer.addEventListener("touchstart", (e) => {
                // Only handle single touch (not pinch zoom)
                // Skip if already handling pinch zoom or multiple touches
                if (e.touches.length !== 1 || isPinching || e.touches.length === 2) {
                    return;
                }

                // Don't interfere with drawing or other interactions
                if (drawingMode !== 'none' || e.target.closest('.draw-canvas') || 
                    e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                    e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                    e.target.closest('#searchPanel') || e.target.closest('.textLayer')) {
                    return;
                }

                touchStartTime = Date.now();
                touchMoved = false;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });

            viewerContainer.addEventListener("touchmove", (e) => {
                // Only handle single touch
                // Skip if already handling pinch zoom or multiple touches
                if (e.touches.length !== 1 || isPinching || e.touches.length === 2) {
                    touchMoved = true;
                    return;
                }

                if (drawingMode !== 'none' || e.target.closest('.draw-canvas')) {
                    return;
                }

                // Check if user is scrolling (moved more than threshold)
                if (e.touches.length > 0) {
                    const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
                    const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
                    if (deltaX > SWIPE_THRESHOLD || deltaY > SWIPE_THRESHOLD) {
                        touchMoved = true;
                    }
                }
            }, { passive: true });

            viewerContainer.addEventListener("touchend", (e) => {
                // Only handle single touch
                // Skip if was pinching or multiple touches
                if (e.changedTouches.length !== 1 || isPinching || e.touches.length === 2) {
                    touchMoved = false;
                    return;
                }

                // Don't interfere with drawing or other interactions
                if (drawingMode !== 'none' || e.target.closest('.draw-canvas') || 
                    e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                    e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                    e.target.closest('#searchPanel') || e.target.closest('.textLayer')) {
                    touchMoved = false;
                    return;
                }

                const touchDuration = Date.now() - touchStartTime;
                
                // Single tap (not a scroll or draw) - toggle controls
                if (!touchMoved && touchDuration < TOUCH_DELAY && touchDuration > 50) {
                    // Check if it's a single tap (not double tap)
                    const timeSinceLastTouch = Date.now() - lastTouchTime;
                    if (timeSinceLastTouch < 400) {
                        // Double tap detected - don't toggle, let zoom handle it
                        lastTouchTime = 0;
                    } else {
                        // Single tap - toggle controls
                        lastTouchTime = Date.now();
                        setTimeout(() => {
                            if (Date.now() - lastTouchTime >= 400) {
                                toggleControls();
                            }
                        }, 400);
                    }
                }
                
                touchMoved = false;
            }, { passive: true });

            // Don't show controls automatically on scroll - only on tap

            // Show controls initially on mobile
            setTimeout(() => {
                showControls();
            }, 1000);
        }

        document.getElementById("penTool").addEventListener("click", () => {
            drawingMode = drawingMode === 'pen' ? 'none' : 'pen';
            updateDrawingMode();
            document.getElementById("penTool").classList.toggle("active", drawingMode === 'pen');
        });

        document.getElementById("eraserTool").addEventListener("click", () => {
            drawingMode = drawingMode === 'eraser' ? 'none' : 'eraser';
            updateDrawingMode();
            document.getElementById("eraserTool").classList.toggle("active", drawingMode === 'eraser');
        });

        // ============================================
        // ZOOM CONTROLS
        // ============================================
        function applyZoom(newZoom) {
            // Enhanced zoom limits for high resolution
            const maxZoom = isIOSSafari ? 200 : 400; // Increased from 150/300
            const minZoom = isIOSSafari ? 75 : 50;
            
            zoomLevel = Math.max(minZoom, Math.min(maxZoom, newZoom));
            
            // Keep scale constant - only change CSS transform for zoom
            // This keeps page size constant while zooming content
            scale = baseScale; // Always use baseScale for rendering
            
            // Update zoom level display
            const zoomLevelEl = document.getElementById("zoomLevel");
            if (zoomLevelEl) {
                zoomLevelEl.textContent = Math.round(zoomLevel) + "%";
            }
            
            // Update slider
            updateZoomSlider();
            
            // Check if zoomed (more than 100%)
            const isZoomed = zoomLevel > 100;
            const container = document.getElementById("viewerContainer");
            
            // Enable/disable horizontal scroll based on zoom level
            if (isZoomed) {
                container.classList.add("zoomed");
            } else {
                container.classList.remove("zoomed");
            }
            
            // Apply CSS transform to all page wrappers instead of re-rendering
            const zoomFactor = zoomLevel / 100;
            pageWrappers.forEach((wrapper, pageNum) => {
                if (wrapper) {
                    // Apply transform to zoom content without changing page size
                    wrapper.style.transform = `scale(${zoomFactor})`;
                    wrapper.style.transformOrigin = "center top";
                    
                    // Enable horizontal scroll on page wrapper when zoomed
                    if (isZoomed) {
                        wrapper.classList.add("zoomed");
                        // Get base width from dataset or calculate it
                        const baseWidth = parseFloat(wrapper.dataset.baseWidth || "0");
                        if (baseWidth > 0) {
                            // Set min-width to allow horizontal scrolling
                            wrapper.style.minWidth = (baseWidth * zoomFactor) + "px";
                        }
                    } else {
                        wrapper.classList.remove("zoomed");
                        wrapper.style.minWidth = "";
                    }
                    
                    // Keep wrapper size constant - store base dimensions
                    if (!wrapper.dataset.baseWidth) {
                        const currentWidth = wrapper.offsetWidth;
                        const currentHeight = wrapper.offsetHeight;
                        const currentScale = wrapper.style.transform ? parseFloat(wrapper.style.transform.match(/scale\(([^)]+)\)/)?.[1] || 1) : 1;
                        wrapper.dataset.baseWidth = (currentWidth / currentScale) + "";
                        wrapper.dataset.baseHeight = (currentHeight / currentScale) + "";
                    }
                }
            });
        }

        // Zoom slider control - now in menu
        let zoomSlider = null;
        let zoomLevelDisplay = null;
        
        // Initialize zoom slider after DOM is ready
        function initZoomSlider() {
            zoomSlider = document.getElementById("zoomSlider");
            zoomLevelDisplay = document.getElementById("zoomLevelDisplay");
            
            if (zoomSlider) {
                // Set initial value
                zoomSlider.value = zoomLevel;
                
                // Zoom slider input
                zoomSlider.addEventListener("input", (e) => {
                    const newZoom = parseInt(e.target.value);
                    applyZoom(newZoom);
                });
            }
        }
        
        // Update slider when zoom changes
        function updateZoomSlider() {
            if (zoomSlider) {
                zoomSlider.value = Math.round(zoomLevel);
            }
            if (zoomLevelDisplay) {
                zoomLevelDisplay.textContent = Math.round(zoomLevel) + "%";
            }
        }
        
        // Initialize after page load
        setTimeout(initZoomSlider, 100);

        document.getElementById("zoomFit").addEventListener("click", () => {
            const container = document.getElementById("viewerContainer");
            const containerWidth = container.clientWidth - 40;
            const standardPageWidth = 612;
            baseScale = containerWidth / standardPageWidth;
            applyZoom(100);
            // Close menu after action
            menuOpen = false;
            menuItems.classList.remove("active");
            menuToggle.classList.remove("active");
            menuToggle.textContent = "‚ò∞";
        });

        document.getElementById("zoomReset").addEventListener("click", () => {
            baseScale = calculateScale();
            applyZoom(100);
            // Close menu after action
            menuOpen = false;
            menuItems.classList.remove("active");
            menuToggle.classList.remove("active");
            menuToggle.textContent = "‚ò∞";
        });

        // Keyboard zoom
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === "=" || e.key === "+") {
                    e.preventDefault();
                    applyZoom(zoomLevel + 25);
                } else if (e.key === "-") {
                    e.preventDefault();
                    applyZoom(zoomLevel - 25);
                } else if (e.key === "0") {
                    e.preventDefault();
                    baseScale = calculateScale();
                    applyZoom(100);
                }
            }
        });

        // ============================================
        // THUMBNAIL SIDEBAR
        // ============================================
        async function generateThumbnails() {
            const thumbnailGrid = document.getElementById("thumbnailGrid");
            thumbnailGrid.innerHTML = "";

            // On iOS, generate thumbnails lazily to save memory
            const batchSize = isIOSSafari ? 5 : 10;
            const delay = isIOSSafari ? 200 : 50;

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                // Create placeholder first
                const thumbnailItem = document.createElement("div");
                thumbnailItem.className = "thumbnail-item";
                thumbnailItem.id = `thumb-${pageNum}`;
                if (pageNum === currentPage) {
                    thumbnailItem.classList.add("active");
                }

                const placeholder = document.createElement("div");
                placeholder.style.cssText = "width:100%;height:120px;background:#2a2a2a;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px;";
                placeholder.textContent = `ÿµŸÅÿ≠ÿ© ${pageNum}`;
                thumbnailItem.appendChild(placeholder);

                const pageNumLabel = document.createElement("div");
                pageNumLabel.className = "thumbnail-page-num";
                pageNumLabel.textContent = `ÿµŸÅÿ≠ÿ© ${pageNum}`;
                thumbnailItem.appendChild(pageNumLabel);

                thumbnailItem.addEventListener("click", () => {
                    scrollToPage(pageNum);
                });

                thumbnailGrid.appendChild(thumbnailItem);

                // Generate thumbnail asynchronously
                (async (pNum) => {
                    try {
                        // Delay for iOS to prevent memory issues
                        if (pNum % batchSize === 0 && isIOSSafari) {
                            await new Promise(r => setTimeout(r, delay));
                        }

                        const page = await pdfDoc.getPage(pNum);
                        const thumbScale = isIOSSafari ? 0.15 : 0.2; // Smaller on iOS
                        const viewport = page.getViewport({ scale: thumbScale });
                        
                        const thumbCanvas = document.createElement("canvas");
                        thumbCanvas.className = "thumbnail-canvas";
                        thumbCanvas.width = viewport.width;
                        thumbCanvas.height = viewport.height;
                        
                        const ctx = thumbCanvas.getContext("2d", { alpha: false });
                        await page.render({
                            canvasContext: ctx,
                            viewport: viewport
                        }).promise;

                        // Replace placeholder with actual thumbnail
                        placeholder.replaceWith(thumbCanvas);
                    } catch (err) {
                        console.error(`Error generating thumbnail for page ${pNum}:`, err);
                        placeholder.textContent = "ÿÆÿ∑ÿ£";
                        placeholder.style.color = "#f00";
                    }
                })(pageNum);
            }
        }

        document.getElementById("toggleThumbnails").addEventListener("click", () => {
            const sidebar = document.getElementById("thumbnailSidebar");
            sidebar.classList.toggle("active");
            document.getElementById("toggleThumbnails").classList.toggle("active");
            
            if (sidebar.classList.contains("active") && thumbnailGrid.children.length === 0) {
                generateThumbnails();
            }
        });

        // Update active thumbnail on page change
        function updateActiveThumbnail() {
            document.querySelectorAll(".thumbnail-item").forEach(item => {
                item.classList.remove("active");
            });
            const activeThumb = document.getElementById(`thumb-${currentPage}`);
            if (activeThumb) {
                activeThumb.classList.add("active");
                activeThumb.scrollIntoView({ block: "nearest" });
            }
        }

        // ============================================
        // SEARCH FUNCTIONALITY
        // ============================================
        async function searchInPDF(query) {
            if (!query || !pdfDoc) return;
            
            searchResults = [];
            currentSearchIndex = -1;
            const resultsContainer = document.getElementById("searchResults");
            resultsContainer.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´...</div>';

            // On iOS, limit search to prevent memory issues
            const maxSearchPages = isIOSSafari ? 50 : pdfDoc.numPages;
            const searchDelay = isIOSSafari ? 100 : 0;

            for (let pageNum = 1; pageNum <= Math.min(maxSearchPages, pdfDoc.numPages); pageNum++) {
                try {
                    // Add delay on iOS to prevent blocking
                    if (pageNum % 10 === 0 && isIOSSafari) {
                        await new Promise(r => setTimeout(r, searchDelay));
                    }

                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const textItems = textContent.items;
                    const fullText = textItems.map(item => item.str).join(" ");
                    
                    if (fullText.toLowerCase().includes(query.toLowerCase())) {
                        const matches = [];
                        let searchIndex = 0;
                        const lowerQuery = query.toLowerCase();
                        const lowerText = fullText.toLowerCase();
                        
                        // Limit matches per page on iOS
                        const maxMatchesPerPage = isIOSSafari ? 5 : 20;
                        let matchCount = 0;
                        
                        while ((searchIndex = lowerText.indexOf(lowerQuery, searchIndex)) !== -1 && matchCount < maxMatchesPerPage) {
                            const start = Math.max(0, searchIndex - 30);
                            const end = Math.min(fullText.length, searchIndex + query.length + 30);
                            const context = fullText.substring(start, end);
                            
                            matches.push({
                                page: pageNum,
                                index: searchIndex,
                                context: context
                            });
                            searchIndex += query.length;
                            matchCount++;
                        }

                        matches.forEach(match => {
                            searchResults.push(match);
                            
                            const resultItem = document.createElement("div");
                            resultItem.className = "search-result-item";
                            resultItem.innerHTML = `
                                <div class="page-num">ÿµŸÅÿ≠ÿ© ${match.page}</div>
                                <div class="context">${match.context.replace(
                                    new RegExp(query, "gi"),
                                    `<span class="search-match">$&</span>`
                                )}</div>
                            `;
                            
                            resultItem.addEventListener("click", () => {
                                scrollToPage(match.page);
                                highlightSearchMatch(match.page, match.index);
                            });
                            
                            resultsContainer.appendChild(resultItem);
                        });
                    }
                } catch (err) {
                    console.error(`Error searching page ${pageNum}:`, err);
                }
            }

            if (searchResults.length === 0) {
                resultsContainer.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨</div>';
            } else if (isIOSSafari && maxSearchPages < pdfDoc.numPages) {
                resultsContainer.innerHTML += `<div style="color: #999; padding: 10px; text-align: center; font-size: 11px;">ÿ™ŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿ£ŸàŸÑ ${maxSearchPages} ÿµŸÅÿ≠ÿ© ŸÅŸÇÿ∑</div>`;
            }
        }

        function highlightSearchMatch(pageNum, index) {
            // Scroll to page and highlight (simplified version)
            scrollToPage(pageNum);
        }

        document.getElementById("toggleSearch").addEventListener("click", () => {
            const panel = document.getElementById("searchPanel");
            panel.classList.toggle("active");
            document.getElementById("toggleSearch").classList.toggle("active");
            if (panel.classList.contains("active")) {
                document.getElementById("searchInput").focus();
            }
        });

        let searchTimeout;
        document.getElementById("searchInput").addEventListener("input", (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchInPDF(e.target.value);
            }, 500);
        });

        // ============================================
        // FULLSCREEN MODE
        // ============================================
        function toggleFullscreen() {
            if (!isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        document.getElementById("toggleFullscreen").addEventListener("click", toggleFullscreen);

        document.addEventListener("fullscreenchange", () => {
            isFullscreen = !!document.fullscreenElement;
            document.body.classList.toggle("fullscreen", isFullscreen);
            document.getElementById("toggleFullscreen").classList.toggle("active", isFullscreen);
        });

        // ============================================
        // NIGHT MODE
        // ============================================
        document.getElementById("toggleNightMode").addEventListener("click", () => {
            isNightMode = !isNightMode;
            document.body.classList.toggle("night-mode", isNightMode);
            document.getElementById("toggleNightMode").classList.toggle("active", isNightMode);
            localStorage.setItem("pdfNightMode", isNightMode);
        });

        // Load saved night mode preference
        if (localStorage.getItem("pdfNightMode") === "true") {
            isNightMode = true;
            document.body.classList.add("night-mode");
            document.getElementById("toggleNightMode").classList.add("active");
        }

        // ============================================
        // TEXT SELECTION MODE
        // ============================================
        document.getElementById("toggleTextSelection").addEventListener("click", () => {
            textSelectionMode = !textSelectionMode;
            document.body.classList.toggle("text-selection-mode", textSelectionMode);
            document.getElementById("toggleTextSelection").classList.toggle("active", textSelectionMode);
            
            // Enable/disable text selection on text layers
            document.querySelectorAll('.textLayer').forEach(textLayer => {
                if (textSelectionMode) {
                    textLayer.style.pointerEvents = 'auto';
                    textLayer.style.userSelect = 'text';
                    textLayer.style.webkitUserSelect = 'text';
                } else {
                    textLayer.style.pointerEvents = 'auto'; // Keep enabled for text selection
                    textLayer.style.userSelect = 'text'; // Always allow text selection
                    textLayer.style.webkitUserSelect = 'text';
                }
            });
            
            if (textSelectionMode) {
                drawingMode = 'none';
                updateDrawingMode();
            }
        });

        // ============================================
        // PAGE ROTATION
        // ============================================
        document.getElementById("rotatePage").addEventListener("click", () => {
            const currentRotation = pageRotations.get(currentPage) || 0;
            const newRotation = (currentRotation + 90) % 360;
            pageRotations.set(currentPage, newRotation);
            
            const pageWrapper = pageWrappers.get(currentPage);
            if (pageWrapper) {
                pageWrapper.className = "page-wrapper";
                if (newRotation === 90) {
                    pageWrapper.classList.add("rotated-90");
                } else if (newRotation === 180) {
                    pageWrapper.classList.add("rotated-180");
                } else if (newRotation === 270) {
                    pageWrapper.classList.add("rotated-270");
                }
            }
        });

        // ============================================
        // READING STATISTICS
        // ============================================
        function updateReadingStats() {
            const readingTime = Math.floor((Date.now() - readingStartTime) / 60000);
            const progress = Math.round((pagesReadSet.size / pdfDoc.numPages) * 100);
            
            document.getElementById("pagesRead").textContent = pagesReadSet.size;
            document.getElementById("readingTime").textContent = readingTime + " ÿØŸÇŸäŸÇÿ©";
            document.getElementById("readingProgressPercent").textContent = progress + "%";
            
            // Update progress bar
            document.getElementById("readingProgress").style.width = progress + "%";
        }

        // Track pages read
        document.getElementById("viewerContainer").addEventListener("scroll", () => {
            pagesReadSet.add(currentPage);
            updateReadingStats();
        });

        document.getElementById("toggleStats").addEventListener("click", () => {
            const statsPanel = document.getElementById("statsPanel");
            statsPanel.classList.toggle("active");
            document.getElementById("toggleStats").classList.toggle("active");
            if (statsPanel.classList.contains("active")) {
                updateReadingStats();
            }
        });

        // ============================================
        // ADDITIONAL ENHANCEMENTS
        // ============================================
        
        // ============================================
        // DOUBLE TAP TO ZOOM (Enhanced - works anywhere)
        // ============================================
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;
        const DOUBLE_TAP_DELAY = 300;
        const DOUBLE_TAP_DISTANCE = 50; // Max distance between taps

        function handleDoubleTap(x, y) {
            const container = document.getElementById("viewerContainer");
            const containerRect = container.getBoundingClientRect();
            
            // Convert tap position to container coordinates
            const relativeX = x - containerRect.left + container.scrollLeft;
            const relativeY = y - containerRect.top + container.scrollTop;
            
            // Comfortable zoom level (200% for reading)
            const targetZoom = zoomLevel === 100 ? 200 : 100;
            
            if (targetZoom > zoomLevel) {
                // Zoom in at tap point
                const oldZoom = zoomLevel;
                const oldScrollLeft = container.scrollLeft;
                const oldScrollTop = container.scrollTop;
                
                applyZoom(targetZoom);
                
                // Adjust scroll to center on tap point
                requestAnimationFrame(() => {
                    const zoomFactor = targetZoom / oldZoom;
                    const newScrollLeft = relativeX - (relativeX - oldScrollLeft) * zoomFactor;
                    const newScrollTop = relativeY - (relativeY - oldScrollTop) * zoomFactor;
                    
                    container.scrollLeft = newScrollLeft;
                    container.scrollTop = newScrollTop;
                });
            } else {
                // Zoom out
                baseScale = calculateScale();
                applyZoom(100);
            }
        }

        // Double tap for mobile
        if (isMobile) {
            viewerContainer.addEventListener("touchend", function handleDoubleTap(e) {
                if (e.touches.length > 0 || isPinching) return; // Don't interfere with pinch or active touches
                
                const currentTime = Date.now();
                const tapX = e.changedTouches[0].clientX;
                const tapY = e.changedTouches[0].clientY;
                
                // Check if it's a double tap
                if (currentTime - lastTapTime < DOUBLE_TAP_DELAY &&
                    Math.abs(tapX - lastTapX) < DOUBLE_TAP_DISTANCE &&
                    Math.abs(tapY - lastTapY) < DOUBLE_TAP_DISTANCE) {
                    
                    e.preventDefault();
                    handleDoubleTap(tapX, tapY);
                    lastTapTime = 0; // Reset to prevent triple tap
                } else {
                    lastTapTime = currentTime;
                    lastTapX = tapX;
                    lastTapY = tapY;
                }
            }, { passive: false });
        }

        // Double click for desktop
        viewerContainer.addEventListener("dblclick", (e) => {
            // Don't interfere with other interactions
            if (e.target.closest('#controls') || e.target.closest('#optionsMenu') || 
                e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                e.target.closest('#searchPanel')) {
                return;
            }
            
            handleDoubleTap(e.clientX, e.clientY);
        });

        // ============================================
        // PAN/DRAG FUNCTIONALITY (Move page when zoomed)
        // ============================================
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartScrollLeft = 0;
        let panStartScrollTop = 0;

        function startPan(e) {
            // Only pan when zoomed in (zoom > 100%)
            if (zoomLevel <= 100) return;
            
            // Don't pan if drawing or other interactions
            if (drawingMode !== 'none' || e.target.closest('.draw-canvas') ||
                e.target.closest('#controls') || e.target.closest('#optionsMenu') ||
                e.target.closest('#zoomControls') || e.target.closest('#thumbnailSidebar') ||
                e.target.closest('#searchPanel')) {
                return;
            }

            isPanning = true;
            const container = document.getElementById("viewerContainer");
            
            if (e.touches && e.touches.length === 1) {
                // Touch
                panStartX = e.touches[0].clientX;
                panStartY = e.touches[0].clientY;
            } else {
                // Mouse
                panStartX = e.clientX;
                panStartY = e.clientY;
            }
            
            panStartScrollLeft = container.scrollLeft;
            panStartScrollTop = container.scrollTop;
            
            // Change cursor
            if (!e.touches) {
                document.body.style.cursor = 'grabbing';
            }
        }

        function doPan(e) {
            if (!isPanning) return;
            
            e.preventDefault();
            const container = document.getElementById("viewerContainer");
            
            let currentX, currentY;
            if (e.touches && e.touches.length === 1) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            
            const deltaX = panStartX - currentX;
            const deltaY = panStartY - currentY;
            
            container.scrollLeft = panStartScrollLeft + deltaX;
            container.scrollTop = panStartScrollTop + deltaY;
        }

        function endPan() {
            if (isPanning) {
                isPanning = false;
                document.body.style.cursor = '';
            }
        }

        // Mouse pan (for desktop when zoomed)
        viewerContainer.addEventListener("mousedown", (e) => {
            if (zoomLevel > 100 && e.button === 0) { // Left mouse button
                startPan(e);
            }
        });

        viewerContainer.addEventListener("mousemove", (e) => {
            if (isPanning) {
                doPan(e);
            }
        });

        viewerContainer.addEventListener("mouseup", endPan);
        viewerContainer.addEventListener("mouseleave", endPan);

        // Touch pan (for mobile when zoomed) - separate handler
        if (isMobile) {
            let touchPanStartTime = 0;
            
            viewerContainer.addEventListener("touchstart", function handlePanStart(e) {
                // Only pan with single touch when zoomed, not during pinch
                if (e.touches.length === 1 && zoomLevel > 100 && !isPinching && !isPanning) {
                    touchPanStartTime = Date.now();
                    startPan(e);
                }
            }, { passive: false, capture: false });

            viewerContainer.addEventListener("touchmove", function handlePanMove(e) {
                // Only pan with single touch when zoomed
                if (e.touches.length === 1 && isPanning && !isPinching) {
                    doPan(e);
                }
            }, { passive: false, capture: false });

            viewerContainer.addEventListener("touchend", function handlePanEnd(e) {
                if (e.touches.length === 0 && isPanning) {
                    endPan();
                }
            }, { passive: true });
        }

        // ============================================
        // PINCH TO ZOOM AT TOUCH POINT (Enhanced)
        // ============================================
        let lastTouchDistance = 0;
        let initialZoomLevel = 100;
        let isPinching = false;
        let pinchStartX = 0;
        let pinchStartY = 0;
        let lastZoomTime = 0;
        const ZOOM_THROTTLE = 50; // Throttle zoom updates to 50ms

        // Separate pinch zoom handler - must be registered before other touch handlers
        const viewerContainer = document.getElementById("viewerContainer");
        
        // Pinch zoom touchstart
        viewerContainer.addEventListener("touchstart", function handlePinchStart(e) {
            // Only handle 2-finger touch
            if (e.touches.length === 2) {
                // Don't interfere with drawing
                if (drawingMode !== 'none' && e.target.closest('.draw-canvas')) {
                    return;
                }
                
                isPinching = true;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point of pinch
                pinchStartX = (touch1.clientX + touch2.clientX) / 2;
                pinchStartY = (touch1.clientY + touch2.clientY) / 2;
                
                // Get initial distance
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Store initial zoom level
                initialZoomLevel = zoomLevel;
            } else {
                isPinching = false;
                lastTouchDistance = 0;
            }
        }, { passive: true, capture: true });

        // Pinch zoom touchmove
        viewerContainer.addEventListener("touchmove", function handlePinchMove(e) {
            if (e.touches.length === 2 && isPinching && lastTouchDistance > 0) {
                // Don't interfere with drawing
                if (drawingMode !== 'none' && e.target.closest('.draw-canvas')) {
                    return;
                }
                
                // Throttle zoom updates
                const now = Date.now();
                if (now - lastZoomTime < ZOOM_THROTTLE) {
                    return;
                }
                lastZoomTime = now;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate zoom change based on distance ratio
                const distanceRatio = currentDistance / lastTouchDistance;
                
                // Calculate new zoom level
                let newZoom = initialZoomLevel * distanceRatio;
                
                // Limit zoom
                const maxZoom = isIOSSafari ? 200 : 400;
                const minZoom = isIOSSafari ? 75 : 50;
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                
                // Get container for scroll calculations
                const container = document.getElementById("viewerContainer");
                const containerRect = container.getBoundingClientRect();
                
                // Calculate current center point
                const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
                const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                // Convert touch center to container coordinates
                const relativeX = currentCenterX - containerRect.left + container.scrollLeft;
                const relativeY = currentCenterY - containerRect.top + container.scrollTop;
                
                // Store old values before zoom
                const oldZoom = zoomLevel;
                const oldScrollLeft = container.scrollLeft;
                const oldScrollTop = container.scrollTop;
                
                // Apply zoom
                applyZoom(newZoom);
                
                // Adjust scroll position to keep touch point in same place
                requestAnimationFrame(() => {
                    const zoomFactor = newZoom / oldZoom;
                    const newScrollLeft = relativeX - (relativeX - oldScrollLeft) * zoomFactor;
                    const newScrollTop = relativeY - (relativeY - oldScrollTop) * zoomFactor;
                    
                    container.scrollLeft = newScrollLeft;
                    container.scrollTop = newScrollTop;
                });
                
                // Update last distance for next calculation
                lastTouchDistance = currentDistance;
                initialZoomLevel = newZoom; // Update base for continuous zoom
            }
        }, { passive: true, capture: true });

        // Pinch zoom touchend
        viewerContainer.addEventListener("touchend", function handlePinchEnd(e) {
            if (e.touches.length < 2) {
                isPinching = false;
                lastTouchDistance = 0;
            }
        }, { passive: true, capture: true });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
            if (e.target.tagName === "INPUT") return;
            
            switch(e.key) {
                case "ArrowRight":
                case "ArrowDown":
                    e.preventDefault();
                    if (pdfDoc && currentPage < pdfDoc.numPages) {
                        scrollToPage(currentPage + 1);
                    }
                    break;
                case "ArrowLeft":
                case "ArrowUp":
                    e.preventDefault();
                    if (pdfDoc && currentPage > 1) {
                        scrollToPage(currentPage - 1);
                    }
                    break;
                case "Home":
                    e.preventDefault();
                    scrollToPage(1);
                    break;
                case "End":
                    e.preventDefault();
                    if (pdfDoc) scrollToPage(pdfDoc.numPages);
                    break;
                case "f":
                case "F":
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        toggleFullscreen();
                    }
                    break;
                case "Escape":
                    if (isFullscreen) {
                        toggleFullscreen();
                    }
                    break;
            }
        });

        // Initialize zoom level display
        document.getElementById("zoomLevel").textContent = zoomLevel + "%";
        
        // ============================================
        // iOS-SPECIFIC OPTIMIZATIONS
        // ============================================
        if (isIOSSafari) {
            // Disable heavy features on iOS
            document.getElementById("toggleThumbnails").style.display = "none"; // Hide thumbnails on iOS initially
            document.getElementById("toggleSearch").style.display = "none"; // Hide search on iOS initially
            
            // Reduce animation complexity
            document.documentElement.style.setProperty('--transition-speed', '0.2s');
            
            // Add memory warning handler
            window.addEventListener("beforeunload", () => {
                // Clean up canvases
                drawCanvases.forEach(canvas => {
                    if (canvas && canvas.width) {
                        canvas.width = 0;
                        canvas.height = 0;
                    }
                });
            });

            // Periodic memory cleanup on iOS
            setInterval(() => {
                if (renderedPages.size > 10) {
                    // Keep only recent 10 pages in memory
                    const pagesArray = Array.from(renderedPages).sort((a, b) => b - a);
                    const pagesToRemove = pagesArray.slice(10);
                    
                    pagesToRemove.forEach(pageNum => {
                        const wrapper = pageWrappers.get(pageNum);
                        if (wrapper && Math.abs(pageNum - currentPage) > 5) {
                            // Remove canvas data but keep wrapper
                            const canvas = drawCanvases.get(pageNum);
                            if (canvas) {
                                const ctx = canvas.getContext("2d");
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                            }
                            renderedPages.delete(pageNum);
                        }
                    });
                }
            }, 30000); // Every 30 seconds
        }
    </script>

</body>
</html>